{
    "version": "https://jsonfeed.org/version/1",
    "title": "minz的筆記本 • All posts by \"面試題目\" category",
    "description": "~~~~~~~",
    "home_page_url": "https://blog.minz.li",
    "items": [
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/OOP/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/OOP/",
            "title": "物件導向傳值?傳參考?",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"call-by-value-傳值\"><a class=\"anchor\" href=\"#call-by-value-傳值\">#</a> call by value (傳值)</h1>\n<ul>\n<li>在 Call-by-Value 中，函式的參數是被傳遞值的<strong>副本</strong>。</li>\n<li>在函式內部，對參數的修改不會影響到原始的變數。</li>\n</ul>\n<div class=\"note info\">\n<h3 id=\"call-by-address-傳位置\"><a class=\"anchor\" href=\"#call-by-address-傳位置\">#</a> call by address (傳位置)</h3>\n<ul>\n<li>傳了實際的記憶體位置進去 function</li>\n<li>也是 <code>call by value</code>  的變形，改為<strong>傳記憶體位址</strong></li>\n</ul>\n</div>\n<h1 id=\"call-by-reference-傳參考\"><a class=\"anchor\" href=\"#call-by-reference-傳參考\">#</a> call by reference (傳參考)</h1>\n<ul>\n<li>在 Call-by-Reference 中，函式的參數接受原始變數的參考（或記憶體位置）。</li>\n<li>在函式內部，對參數的修改會直接影響到原始的變數。</li>\n</ul>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n\n// Call-by-Value (值傳遞)\nvoid incrementByValue(int value) &#123;\n    value++;\n&#125;\n\n// Call-by-Reference using pointer (指標參考傳遞)\nvoid incrementByPointer(int* ptr) &#123;\n    (*ptr)++;\n&#125;\n\n// Call-by-Reference using reference (參考傳遞)\nvoid incrementByReference(int&amp; ref) &#123;\n    ref++;\n&#125;\n\nint main() &#123;\n    int num = 10;\n\n    incrementByValue(num);        // 傳遞值\n    std::cout &lt;&lt; &quot;Call-by-Value: &quot; &lt;&lt; num &lt;&lt; std::endl;  // 輸出：10\n\n    incrementByPointer(&amp;num);     // 傳遞指標參考\n    std::cout &lt;&lt; &quot;Call-by-Pointer: &quot; &lt;&lt; num &lt;&lt; std::endl; // 輸出：11\n\n    incrementByReference(num);    // 傳遞參考\n    std::cout &lt;&lt; &quot;Call-by-Reference: &quot; &lt;&lt; num &lt;&lt; std::endl; // 輸出：12\n\n    return 0;\n&#125;\n\n</code></pre>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">傳值</th>\n<th style=\"text-align:center\">傳地址</th>\n<th style=\"text-align:center\">傳參考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"><code>incrementByValue</code></td>\n<td style=\"text-align:center\"><code>incrementByPointer</code></td>\n<td style=\"text-align:center\"><code>incrementByReference</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">傳入函式的東西</td>\n<td style=\"text-align:center\">整數值</td>\n<td style=\"text-align:center\">整數指標 (指標變數)</td>\n<td style=\"text-align:center\">整數引用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">原始的 <code>num</code></td>\n<td style=\"text-align:center\">不影響 (因為是副本)</td>\n<td style=\"text-align:center\">會影響</td>\n<td style=\"text-align:center\">會影響</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "物件導向"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9/",
            "title": "二元搜尋樹",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"binary-search-tree\"><a class=\"anchor\" href=\"#binary-search-tree\">#</a> Binary Search Tree</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\n// 定義二元搜尋樹的節點結構\nstruct Node &#123;\n    int data;\n    Node* left;\n    Node* right;\n\n    // 節點的建構函式\n    Node(int value) &#123;\n        data = value;\n        left = nullptr;\n        right = nullptr;\n    &#125;\n&#125;;\n\n// 搜尋操作\nbool search(Node* root, int value) &#123;\n    // 若樹為空或找到了目標值，則返回 true\n    if (root == nullptr || root-&gt;data == value) &#123;\n        return true;\n    &#125;\n\n    // 若目標值比根節點的值小，則在左子樹中搜尋\n    if (value &lt; root-&gt;data) &#123;\n        return search(root-&gt;left, value);\n    &#125;\n\n    // 若目標值比根節點的值大，則在右子樹中搜尋\n    return search(root-&gt;right, value);\n&#125;\n\n// 插入操作\nNode* insert(Node* root, int value) &#123;\n    // 若樹為空，則創建一個新節點並返回\n    if (root == nullptr) &#123;\n        return new Node(value);\n    &#125;\n\n    // 若目標值比根節點的值小，則插入左子樹中\n    if (value &lt; root-&gt;data) &#123;\n        root-&gt;left = insert(root-&gt;left, value);\n    &#125;\n\n    // 若目標值比根節點的值大，則插入右子樹中\n    if (value &gt; root-&gt;data) &#123;\n        root-&gt;right = insert(root-&gt;right, value);\n    &#125;\n\n    // 返回根節點\n    return root;\n&#125;\n\n// 刪除操作\nNode* remove(Node* root, int value) &#123;\n    // 若樹為空，則返回空指針\n    if (root == nullptr) &#123;\n        return root;\n    &#125;\n\n    // 若目標值比根節點的值小，則在左子樹中刪除\n    if (value &lt; root-&gt;data) &#123;\n        root-&gt;left = remove(root-&gt;left, value);\n    &#125;\n    // 若目標值比根節點的值大，則在右子樹中刪除\n    else if (value &gt; root-&gt;data) &#123;\n        root-&gt;right = remove(root-&gt;right, value);\n    &#125;\n    // 若找到了目標值\n    else &#123;\n        // 情況1：沒有子節點或只有一個子節點\n        if (root-&gt;left == nullptr) &#123;\n            Node* temp = root-&gt;right;\n            delete root;\n            return temp;\n        &#125;\n        else if (root-&gt;right == nullptr) &#123;\n            Node* temp = root-&gt;left;\n            delete root;\n            return temp;\n        &#125;\n\n        // 情況2：有兩個子節點\n        // 找到右子樹中的最小值節點\n        Node* minNode = root-&gt;right;\n        while (minNode-&gt;left != nullptr) &#123;\n            minNode = minNode-&gt;left;\n        &#125;\n        // 複製最小值到目標節點\n        root-&gt;data = minNode-&gt;data;\n        // 在右子樹中刪除最小值節點\n        root-&gt;right = remove(root-&gt;right, minNode-&gt;data);\n    &#125;\n\n    // 返回修改後的根節點\n    return root;\n&#125;\n\n// 測試程式碼\nint main() &#123;\n    // 建立一個二元搜尋樹\n    Node* root = nullptr;\n    root = insert(root, 50);\n    root = insert(root, 30);\n    root = insert(root, 20);\n    root = insert(root, 40);\n    root = insert(root, 70);\n    root = insert(root, 60);\n    root= insert(root, 80);\n\n    // 搜尋值 40\n    if (search(root, 40)) &#123;\n        cout &lt;&lt; &quot;搜尋到值 40&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;未找到值 40&quot; &lt;&lt; endl;\n    &#125;\n\n    // 刪除值 30\n    root = remove(root, 30);\n\n    // 搜尋值 30\n    if (search(root, 30)) &#123;\n        cout &lt;&lt; &quot;搜尋到值 30&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;未找到值 30&quot; &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<p>我們使用  <code>struct</code>  定義了二元搜尋樹的節點結構，每個節點包含一個整數數據、左子樹指針和右子樹指針。</p>\n<p><code>search</code>  函式實現了搜尋操作。它遞迴地在二元搜尋樹中搜尋目標值，若樹為空或找到了目標值則返回  <code>true</code> ，否則根據目標值與根節點數據的比較結果遞迴地在左子樹或右子樹中搜尋。</p>\n<p><code>insert</code>  函式實現了插入操作。它遞迴地在二元搜尋樹中找到合適的位置插入新節點，若樹為空則創建一個新節點，否則根據目標值與根節點數據的比較結果遞迴地在左子樹或右子樹中插入。</p>\n<p><code>remove</code>  函式實現了刪除操作。它遞迴地在二元搜尋樹中找到目標值所在的節點，並根據不同情況進行刪除。若目標節點沒有子節點或只有一個子節點，則直接刪除該節點並返回相應的子節點。若目標節點有兩個子節點，則找到右子樹中的最小值節點，將最小值複製到目標節點，然後在右子樹中刪除最小值節點。</p>\n<p>在  <code>main</code>  函式中，我們插入了一些節點，然後使用  <code>search</code>  函式搜尋值 40，並根據結果輸出相應的訊息。<br />\n接著，我們刪除值 30 的節點，再次使用  <code>search</code>  函式搜尋值 30，並根據結果輸出相應的訊息。</p>\n",
            "tags": [
                "程式碼"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "title": "作業系統",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"race-condition-是什麼\"><a class=\"anchor\" href=\"#race-condition-是什麼\">#</a> Race Condition 是什麼？</h1>\n<p><strong>競爭條件 (Race Condition)</strong> 是當兩個或多個異步運行的程式碼（例如，中斷和背景迴圈）更改 <strong>共享資源 (Share Resource)</strong> 時會發生的情況。</p>\n<p>例如，假設我們有兩個 Process A 和 B，都想要訪問同一個共享變量。如果 A 和 B 都嘗試在同一時間讀取和修改這個變量，那麼就<strong>可能</strong>會產生競爭條件。<br />\n如果沒有提供<strong>互斥存取</strong>，我們<strong>無法確定</strong> A 和 B 的執行順序，所以最終的結果可能會有所<strong>不同</strong>。</p>\n<p>解決方式:</p>\n<ul>\n<li>鎖 (Locks)</li>\n<li>原子變量 (Atomic Variables)</li>\n</ul>\n<h1 id=\"同步-synchronization\"><a class=\"anchor\" href=\"#同步-synchronization\">#</a> 同步 (Synchronization)</h1>\n<p>主要目的是確保多個進程訪問共享資源時不會互相干擾，並防止由於並發訪問而可能產生的數據不一致</p>\n<p>為了實現這一點，我們可以使用各種同步技術，</p>\n<ul>\n<li>信號量（semaphores）</li>\n<li>監視器（monitors）</li>\n<li>臨界區（critical sections）</li>\n</ul>\n<p>例如，有兩個進程 A 和 B，它們都想要訪問同一個共享變數 (share variable)。</p>\n<h2 id=\"信號量semaphores\"><a class=\"anchor\" href=\"#信號量semaphores\">#</a> 信號量（semaphores）</h2>\n<ul>\n<li>我們可以初始化一個信號量並將其設置為 1。</li>\n<li>當進程 A 想要訪問共享變量時，它會先減少信號量的值。</li>\n<li>如果信號量的值大於等於 0，那麼 A 可以繼續執行並訪問共享變量。</li>\n<li>否則，A 將被阻塞並等待。</li>\n<li>當 A 完成對共享變量的訪問後，它會增加信號量的值，這可能會喚醒等待的進程 B2</li>\n</ul>\n<pre><code class=\"language-C++\">mutex semaphore = 1;\nwhile(true)&#123;\n    wait(mutex); // 檢查&gt;0通過並-1\n        臨界區程式碼...\n    signal(mutex); // 離開時+1\n        臨界區以外程式碼...\n&#125;\n</code></pre>\n<h2 id=\"臨界區critical-sections\"><a class=\"anchor\" href=\"#臨界區critical-sections\">#</a> 臨界區（critical sections）</h2>\n<pre><code class=\"language-C++\">// 臨界區指的是有使用共享變數之區塊\nwhile(true)&#123;\n    (進入區段)\n        臨界區程式碼...\n    (離開區段)\n        臨界區以外程式碼...\n&#125;\n\n</code></pre>\n<h1 id=\"process和thread\"><a class=\"anchor\" href=\"#process和thread\">#</a> Process 和 Thread</h1>\n<p><strong>程序 (Process)</strong> 和 <strong>線程 (Thread)</strong> 是兩種不同的執行實體，都是 CPU 調度和執行的基本單位。</p>\n<p><strong>Process</strong> 有 Process Control Block (PCB)。</p>\n<ol>\n<li>PID</li>\n<li>程式計數器 (Program counter)</li>\n<li>CPU 暫存器內容</li>\n<li>Stack</li>\n<li>Code 區段</li>\n<li>Data 區段</li>\n<li>Heap</li>\n</ol>\n<div class=\"note info\">\n<p><strong>Thread</strong> 是一個半進程，它有自己的堆疊並執行一段給定的代碼。<br>與真正的進程不同，<strong>線程通常與其他線程共享其記憶體</strong>。<br />\n進程通常對每一個都有一個不同的記憶體區域。<strong>一個進程可以有多個線程在運行</strong>。</p>\n</div>\n<p>例如，假設我們有一個文字處理器程式。<br />\n該程式可能有<strong>一個主 Process</strong> 負責管理用戶界面，<br />\n以及<strong>多個線程</strong>負責處理後台任務，如保存文件、檢查拼寫和語法等。</p>\n<h1 id=\"content-switch-是什麼\"><a class=\"anchor\" href=\"#content-switch-是什麼\">#</a> Content Switch 是什麼？</h1>\n<p><strong>Context Switch</strong>（上下文切換）是一種系統事件，使得單個 CPU 能夠被多個進程共享的重要機制，它允許作業系統在多個進程之間進行切換，使得每個進程都有機會使用 CPU 來完成其執行。</p>\n<div class=\"note info\">\n<p>例如，假設我們有兩個進程 A 和 B。A 正在 CPU 上運行，而 B 在等待 CPU。當作業系統決定讓 B 運行時，它會進行上下文切換。</p>\n</div>\n<ol>\n<li>保存 A 的當前狀態（包括程序計數器、暫存器的值等），</li>\n<li>然後加載 B 的狀態並讓 B 運行。</li>\n<li>當要讓 A 再次運行時，作業系統會再次進行上下文切換，恢復 A 的狀態並讓 A 運行。</li>\n</ol>\n<h1 id=\"deadlock\"><a class=\"anchor\" href=\"#deadlock\">#</a> DeadLock</h1>\n<ol>\n<li>Mutual exlusion 互斥存取</li>\n<li>Hold &amp; Wait 拿了其他 Process 需要的資源並等待</li>\n<li>No preemption 不搶佔</li>\n<li>Circular wait 循環等待</li>\n</ol>\n",
            "tags": [
                "大學課程"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/",
            "title": "排序演算法",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<ul>\n<li>stable sorting : 相同的值排序後順序皆一樣</li>\n<li>unstable sorting : 相同的值排序後順序可能會不一樣</li>\n</ul>\n<h1 id=\"初階排序\"><a class=\"anchor\" href=\"#初階排序\">#</a> 初階排序</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n// Bubble Sort mark:3-4\nvoid bubbleSort(vector&lt;int&gt;&amp; arr) &#123;\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) &#123;\n        for (int j = 0; j &lt; n - i - 1; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                swap(arr[j], arr[j + 1]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n// Selection Sort\n// 1. 先選這輪的最小\n// 2. 跟i交換\nvoid selectionSort(vector&lt;int&gt;&amp; arr) &#123;\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) &#123;\n        int minIndex = i;\n        for (int j = i + 1; j &lt; n; j++) &#123;\n            if (arr[j] &lt; arr[minIndex]) &#123;\n                minIndex = j; \n            &#125;\n        &#125;\n        swap(arr[i], arr[minIndex]);\n    &#125;\n&#125;\n\n// Insertion Sort\n// 1. 依序給這一輪的value\n// 2. value跟前面的比\n// 3. 放到完成的位置\nvoid insertionSort(vector&lt;int&gt;&amp; arr) &#123;\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) &#123;\n        int key = arr[i];\n        int j = i - 1;\n        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123;\n            arr[j + 1] = arr[j];\n            j--;\n        &#125;\n        arr[j + 1] = key;\n    &#125;\n&#125;\n\nint main() &#123;\n    vector&lt;int&gt; arr = &#123;5, 2, 8, 3, 1&#125;;\n\n    // Bubble Sort\n    bubbleSort(arr);\n    cout &lt;&lt; &quot;Bubble Sort: &quot;;\n    for (int num : arr) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    // Selection Sort\n    arr = &#123;5, 2, 8, 3, 1&#125;;\n    selectionSort(arr);\n    cout &lt;&lt; &quot;Selection Sort: &quot;;\n    for (int num : arr) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    // Insertion Sort\n    arr = &#123;5, 2, 8, 3, 1&#125;;\n    insertionSort(arr);\n    cout &lt;&lt; &quot;Insertion Sort: &quot;;\n    for (int num : arr) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"quick-sort\"><a class=\"anchor\" href=\"#quick-sort\">#</a> Quick sort</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 快速排序 (Quick Sort)\n// 最壞情況時間複雜度：O(n^2)\n// 平均情況時間複雜度：O(nlogn)\n// 最佳情況時間複雜度：O(nlogn)\nint partition(vector&lt;int&gt;&amp; arr, int low, int high) &#123;\n    int pivot = arr[high]; // 選擇最後一個元素作為主元\n    int i = low - 1;\n\n    for (int j = low; j &lt; high; j++) &#123;\n        if (arr[j] &lt; pivot) &#123;\n            i++;\n            swap(arr[i], arr[j]);\n        &#125;\n    &#125;\n\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n&#125;\n\nvoid quickSort(vector&lt;int&gt;&amp; arr, int low, int high) &#123;\n    if (low &lt; high) &#123;\n        int pivotIndex = partition(arr, low, high);\n\n        // 遞迴地對分割後的子陣列進行排序\n        quickSort(arr, low, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, high);\n    &#125;\n&#125;\nint main() &#123;\n    vector&lt;int&gt; arr = &#123;5, 2, 8, 3, 1&#125;;\n\n    // 快速排序\n    cout &lt;&lt; &quot;快速排序結果：&quot; &lt;&lt; endl;\n    quickSort(arr, 0, arr.size() - 1);\n    for (int num : arr) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n</code></pre>\n<p>在快速排序中，我們使用  <code>partition</code>  函式將陣列分割為比主元小和比主元大的兩個子陣列。<br />\n然後，我們遞迴地對這兩個子陣列進行排序，直到排序完成。</p>\n",
            "tags": [
                "程式碼"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%A9%9F%E7%8E%87%E8%88%87%E7%B5%B1%E8%A8%88/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%A9%9F%E7%8E%87%E8%88%87%E7%B5%B1%E8%A8%88/",
            "title": "機率與統計",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"互斥和獨立事件\"><a class=\"anchor\" href=\"#互斥和獨立事件\">#</a> 互斥和獨立事件</h1>\n<p><strong>互斥事件</strong>指的是兩個或多個事件不可能同時發生的情況。<br />\n如果事件 A 發生，那麼事件 B 就不可能發生，且反之亦然。</p>\n<p>數學上，兩個互斥事件 A 和 B 的概率滿足 P (A ∩ B) = 0，<strong>即它們的交集為空集</strong>。</p>\n<p>例如，擲一個骰子，事件 A 是出現奇數點數，事件 B 是出現偶數點數。由於奇數和偶數是互斥的，因此在一次擲骰子的結果中，不能同時出現奇數和偶數。因此，事件 A 和事件 B 是互斥事件。</p>\n<hr />\n<p><strong>獨立事件</strong>指的是兩個或多個事件的發生與其他事件的發生無關。<br />\n如果事件 A 發生與否<strong>不會影響</strong>事件 B 發生的概率，其概率滿足乘法規則。<br />\n兩個獨立事件 A 和 B 的概率滿足 P (A ∩ B) = P (A) * P (B)。</p>\n<p>例如，考慮一個從一副撲克牌中抽取兩張牌的實驗，事件 A 是第一張牌是紅心，事件 B 是第二張牌是黑桃。由於每次抽取牌都是獨立的，第一張牌是紅心不會影響第二張牌是黑桃的概率，反之亦然。因此，事件 A 和事件 B 是獨立事件。</p>\n<h1 id=\"骰1個骰子的期望值怎麼算\"><a class=\"anchor\" href=\"#骰1個骰子的期望值怎麼算\">#</a> 骰 1 個骰子的期望值怎麼算？</h1>\n<p>期望值是 相加所有 (出現的值 * 出現的機率)</p>\n<p>期望值 = (1 × 1/6) + (2 × 1/6) + (3 × 1/6) + (4 × 1/6) + (5 × 1/6) + (6 × 1/6) = 3.5</p>\n<details><summary>骰的次數越多總平均會接近期望值</summary><div>\n<p>期望值 3.5 表示在長期多次擲骰子的情況下，<br />\n擲骰子的平均結果將趨近於 3.5。</p>\n</div></details>\n<h1 id=\"三顆骰子一奇數二偶數的機率\"><a class=\"anchor\" href=\"#三顆骰子一奇數二偶數的機率\">#</a> 三顆骰子，一奇數二偶數的機率</h1>\n<p>現在，我們需要確定符合要求的<strong>組合數</strong>。我們希望有一顆骰子是奇數，而另外兩顆骰子是偶數。這種情況下，有三種可能性：</p>\n<ol>\n<li>奇數 - 偶數 - 偶數</li>\n<li>偶數 - 奇數 - 偶數</li>\n<li>偶數 - 偶數 - 奇數</li>\n</ol>\n<p>對於每種可能性，我們需要計算出每顆骰子的組合數。奇數有三種選擇（1、3、5），而偶數有三種選擇（2、4、6）。</p>\n<p>因此，根據組合計數的原理，我們可以計算滿足要求的組合數為：</p>\n<ol>\n<li>3 (奇數選擇) * 3 (偶數選擇) * 3 (偶數選擇) = 27</li>\n<li>3 (偶數選擇) * 3 (奇數選擇) * 3 (偶數選擇) = 27</li>\n<li>3 (偶數選擇) * 3 (偶數選擇) * 3 (奇數選擇) = 27</li>\n</ol>\n<p>接下來，我們需要考慮所有可能的組合數。每顆骰子有六個可能的點數，所以總共有 6 * 6 * 6 = 216 種可能的組合。</p>\n<p>最後，我們可以計算機率，即符合要求的組合數除以所有可能的組合數：</p>\n<p>機率 = 符合要求的組合數 / 所有可能的組合數 = (27+27+27) / 216</p>\n<h1 id=\"完整撲克牌任意抽五張數字都不一樣的機率為何\"><a class=\"anchor\" href=\"#完整撲克牌任意抽五張數字都不一樣的機率為何\">#</a> 完整撲克牌任意抽五張數字都不一樣的機率為何？</h1>\n<p>撲克牌的數量為 52 張，再加上 2 張鬼牌，總共有 54 張牌。數字為 1 到 10 還有 J Q K，有 4 種花色。我們來計算一次抽取五張數字都不一樣（不管花色）的機率。</p>\n<p>首先，我們需要確定有多少種不同的數字。在撲克牌中，有 13 種不同的數字（1-10，J，Q，K）。因此，第一張牌可以有 13 種選擇，第二張牌可以有 12 種選擇（因為不能與第一張牌的數字相同），依此類推，直到第五張牌只有 9 種選擇。</p>\n<p>因此，符合條件的組合數為 13 * 12 * 11 * 10 * 9。</p>\n<p>然後，我們需要考慮所有可能的組合數。每次抽牌都有 54 種可能（52 張撲克牌和 2 張鬼牌），所以五次抽牌總共有 C (54,5) 種可能的組合。</p>\n<p>最後，我們可以計算機率，即符合要求的組合數除以所有可能的組合數：</p>\n<p>機率 = 符合要求的組合數 / 所有可能的組合數 = (13 * 12 * 11 * 10 * 9) / C (54,5)</p>\n<h1 id=\"有五個銅板有四個正面的機率是多少\"><a class=\"anchor\" href=\"#有五個銅板有四個正面的機率是多少\">#</a> 有五個銅板，有四個正面的機率是多少？</h1>\n<p>我們有五個銅板，每個銅板都有兩種可能的結果：正面和反面。<br />\n因此，總共有 2^5 = 32 種不同的組合。</p>\n<p>現在我們要計算有四個正面的組合數。在五個銅板中，選擇四個銅板出現正面，剩下的一個銅板出現反面。這種情況有 C (5, 4) = 5 種組合。</p>\n<p>每個符合條件的組合中，有四個銅板出現正面，一個銅板出現反面。因此，我們可以將每個銅板出現正面的機率相乘，並將其乘以符合條件的組合數。</p>\n<p>所以，機率 = C (5, 4) * p^4 * (1-p)^1 = 5 * (1/2)^4 * (1/2)^1 = 5/32</p>\n<h1 id=\"pdf跟cdf是什麼\"><a class=\"anchor\" href=\"#pdf跟cdf是什麼\">#</a> PDF 跟 CDF 是什麼</h1>\n<ul>\n<li>概率密度函數（Probability Density Function, PDF）<br />\n<img data-src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Boxplot_vs_PDF.svg/1024px-Boxplot_vs_PDF.svg.png\"  height=\"300\"></li>\n</ul>\n<p>概率密度函數（PDF）用於描述連續隨機變量在不同<strong>取值點</strong>上的概率密度。<br />\n它可以看作是概率分布曲線的密度，通常是一個平滑的曲線。<br />\nPDF 的值代表了在特定取值點上的概率密度，即該點附近的概率密度值有多大。<br />\nPDF 的積分對應於在整個定義域上的概率，其積分值等於 1。</p>\n<ul>\n<li>累積分佈函數（Cumulative Distribution Function, CDF）<br />\n<img data-src=\"https://upload.wikimedia.org/wikipedia/commons/7/77/Exponential_distribution_cdf.png\"  height=\"300\"></li>\n</ul>\n<p>累積分佈函數（CDF）則用於描述<strong>隨機變量小於或等於給定值的概率</strong>。<br />\n它表示了隨機變量取值小於或等於某一特定值的概率。<br />\nCDF 是一個非遞減的函數，其值域在 0 到 1 之間。<br />\nCDF 的值在 x 處給出了小於或等於 x 的概率。</p>\n<p><strong>CDF 是 PDF 的積分，也就是將 PDF 曲線下的面積進行累加。</strong></p>\n<h1 id=\"什麼是gaussian-function\"><a class=\"anchor\" href=\"#什麼是gaussian-function\">#</a> 什麼是 Gaussian function</h1>\n<p>高斯函數（Gaussian function）是一種數學函數，也稱為<strong>常態分佈函數</strong>（normal distribution function）或高斯分佈函數（Gaussian distribution function）。</p>\n<div class=\"note info\">\n<p>f(x) = A * exp(-(x - μ)² / (2σ²))</p>\n</div>\n<p>σ = 標準差<br />\n σ² = 變異數<br />\n在這個公式中，f (x) 是函數在 x 點的值，A 是幅度（或最大值），μ 是平均值，σ 是標準差，exp 是自然指數函數。</p>\n<p>高斯函數通常呈現一個對稱的鐘形曲線，其峰值位於平均值 μ 的位置。標準差 σ 確定了曲線的寬度，越大曲線越寬，越小曲線越窄。</p>\n<ol>\n<li>對稱性：曲線以平均值為中心對稱。</li>\n<li>唯一峰值：曲線有一個單一的最大值。</li>\n<li>平穩性：曲線在平均值兩側遞減，沒有突變或跳躍。</li>\n</ol>\n",
            "tags": [
                "機率與統計"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%BC%94%E7%AE%97%E6%B3%95/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%BC%94%E7%AE%97%E6%B3%95/",
            "title": "演算法",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"dp跟divide-and-conquer差在哪\"><a class=\"anchor\" href=\"#dp跟divide-and-conquer差在哪\">#</a> DP 跟 divide and conquer 差在哪</h1>\n<p><strong>分而治之法 (Divide and Conquer)</strong>  如果問題很大，我們就把問題<strong>分解成較小的子問題</strong>，然後分別解決這些子問題。一旦所有的子問題都解決了，我們就把所有子問題的解決方案組合起來，找到大問題的解決方案。分治法的限制是子問題應該與主要問題相同。例如，如果主要問題是排序，那麼子問題也應該是排序。分治法的策略本質上是遞迴的。</p>\n<p>動態規劃 (<strong>Dynamic Programming</strong>) 則是將優化問題分解成更簡單的子問題，並<strong>存儲</strong>每個子問題的解決方案，以便每個子問題只需要解決一次。一旦所有的子問題都解決了，我們就將每個子問題的結果連接起來，找到初始問題的解決方案。</p>\n<p>當我們看到一個遞迴解決方案對於相同的輸入有重複的調用時，我們可以使用動態規劃來優化它。</p>\n<p>這種方法的想法是簡單地<strong>存儲子問題</strong>的結果，這樣我們就不需要在以後需要時重新計算它們。</p>\n<p>例如，如果我們寫出斐波那契數列的簡單遞迴解決方案，我們會得到指數時間複雜度，如果我們通過存儲子問題的解決方案來優化它，時間複雜度就會從指數級<strong>降低到多項式級</strong>。</p>\n<h1 id=\"quick-sort\"><a class=\"anchor\" href=\"#quick-sort\">#</a> Quick sort</h1>\n<p>快速排序（Quick Sort）是一種常用的排序算法，它通過選擇一個基準元素，將數列分割成兩個子數列，並將比基準元素小的元素放在基準元素的左邊，比基準元素大的元素放在基準元素的右邊，然後對子數列進行遞迴排序，最終實現整個數列的排序。</p>\n<p>下面是一個簡單的範例來說明快速排序的過程：</p>\n<p>假設我們要對數列 [7, 2, 1, 6, 8, 5, 3] 進行排序。</p>\n<ol>\n<li>選擇基準元素：從數列中選擇一個基準元素，通常選擇第一個或最後一個元素。在這個例子中，我們選擇第一個元素 7 作為基準元素。</li>\n<li>分割操作：將數列分割成兩個子數列，小於基準元素的元素放在左邊，大於基準元素的元素放在右邊。在這個例子中，我們將小於 7 的元素放在左邊，大於 7 的元素放在右邊，得到 [2, 1, 6, 5, 3, 7, 8]。</li>\n<li>遞迴排序：對左右兩個子數列進行遞迴排序，重複上述步驟。在這個例子中，我們對左子數列 [2, 1, 6, 5, 3] 和右子數列 [8] 進行遞迴排序。</li>\n<li>合併結果：將排序後的左子數列、基準元素和排序後的右子數列合併在一起。在這個例子中，最終得到排序後的數列 [1, 2, 3, 5, 6, 7, 8]。</li>\n</ol>\n<p>總結：<br />\n快速排序通過選擇基準元素，將數列分割成兩個子數列，並對子數列進行遞迴排序，最終實現整個數列的排序。它的核心操作是分割，將小於基準元素的元素放在左邊，大於基準元素的元素放在右邊。快速排序是一種高效的排序算法，平均時間複雜度為 O (nlogn)，但在最壞情況下可能達到 O (n^2)。</p>\n",
            "tags": [
                "演算法"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%9F%A9%E9%99%A3%E9%A1%8C%E7%9B%AE/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%9F%A9%E9%99%A3%E9%A1%8C%E7%9B%AE/",
            "title": "矩陣程式題目",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"找出矩陣中第二大的數字\"><a class=\"anchor\" href=\"#找出矩陣中第二大的數字\">#</a> 找出矩陣中第二大的數字</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt; // 包含 INT_MIN 的定義\n\nusing namespace std;\n\nint findSecondLargest(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n    int largest = INT_MIN; // 最大數字\n    int secondLargest = INT_MIN; // 第二大數字\n\n    // 遍歷矩陣，找出最大數字和第二大數字\n    for (const auto&amp; row : matrix) &#123;\n        for (int num : row) &#123;\n            if (num &gt; largest) &#123;\n                secondLargest = largest;\n                largest = num;\n            &#125; else if (num &gt; secondLargest &amp;&amp; num &lt; largest) &#123;\n                secondLargest = num;\n            &#125;\n        &#125;\n    &#125;\n\n    return secondLargest;\n&#125;\n\nint main() &#123;\n    // 定義矩陣\n    vector&lt;vector&lt;int&gt;&gt; matrix = &#123;\n        &#123;4, 5, 6&#125;,\n        &#123;7, 10, 9&#125;,\n        &#123;2, 8, 3&#125;\n    &#125;;\n\n    // 呼叫函式找出第二大的數字\n    int secondLargest = findSecondLargest(matrix);\n\n    // 輸出結果\n    if (secondLargest != INT_MIN) &#123;\n        cout &lt;&lt; &quot;矩陣中第二大的數字為: &quot; &lt;&lt; secondLargest &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;矩陣中沒有第二大的數字&quot; &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"轉置矩陣\"><a class=\"anchor\" href=\"#轉置矩陣\">#</a> 轉置矩陣</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MAX_SIZE = 100;  // 定義矩陣的最大大小\n\n// 函數：計算矩陣的轉置\nvoid transposeMatrix(int matrix[][MAX_SIZE], int rows, int cols) &#123;\n    int transposedMatrix[MAX_SIZE][MAX_SIZE];  // 用於儲存轉置後的矩陣\n\n    // 遍歷矩陣元素，進行轉置\n    for (int i = 0; i &lt; rows; i++) &#123;\n        for (int j = 0; j &lt; cols; j++) &#123;\n            transposedMatrix[j][i] = matrix[i][j];\n        &#125;\n    &#125;\n\n    // 列印轉置後的矩陣\n    cout &lt;&lt; &quot;轉置矩陣：&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; cols; i++) &#123;\n        for (int j = 0; j &lt; rows; j++) &#123;\n            cout &lt;&lt; transposedMatrix[i][j] &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n    int matrix[MAX_SIZE][MAX_SIZE];  // 定義原始矩陣\n    int rows, cols;  // 矩陣的行數和列數\n\n    // 輸入矩陣的行數和列數\n    cout &lt;&lt; &quot;請輸入矩陣的行數：&quot;;\n    cin &gt;&gt; rows;\n    cout &lt;&lt; &quot;請輸入矩陣的列數：&quot;;\n    cin &gt;&gt; cols;\n\n    // 輸入矩陣元素\n    cout &lt;&lt; &quot;請輸入矩陣的元素：&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; rows; i++) &#123;\n        for (int j = 0; j &lt; cols; j++) &#123;\n            cin &gt;&gt; matrix[i][j];\n        &#125;\n    &#125;\n\n    // 調用函數計算矩陣的轉置\n    transposeMatrix(matrix, rows, cols);\n\n    return 0;\n&#125;\n</code></pre>\n<h1 id=\"兩個矩陣相乘\"><a class=\"anchor\" href=\"#兩個矩陣相乘\">#</a> 兩個矩陣相乘</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 函式：矩陣相乘\nvector&lt;vector&lt;int&gt;&gt; matrixMultiply(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix1, const vector&lt;vector&lt;int&gt;&gt;&amp; matrix2) &#123;\n    int rows1 = matrix1.size();    // 矩陣1的列數\n    int cols1 = matrix1[0].size(); // 矩陣1的行數（矩陣2的列數）\n    int cols2 = matrix2[0].size(); // 矩陣2的行數\n\n    // 建立結果矩陣，初始化為全0\n    vector&lt;vector&lt;int&gt;&gt; result(rows1, vector&lt;int&gt;(cols2, 0));\n\n    // 進行矩陣相乘運算\n    for (int i = 0; i &lt; rows1; i++) &#123;\n        for (int j = 0; j &lt; cols2; j++) &#123;\n            for (int k = 0; k &lt; cols1; k++) &#123;\n                result[i][j] += matrix1[i][k] * matrix2[k][j];\n            &#125;\n        &#125;\n    &#125;\n\n    return result;\n&#125;\n\nint main() &#123;\n    // 定義兩個矩陣\n    vector&lt;vector&lt;int&gt;&gt; matrix1 = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;;\n    vector&lt;vector&lt;int&gt;&gt; matrix2 = &#123;&#123;5, 6&#125;, &#123;7, 8&#125;&#125;;\n\n    // 呼叫矩陣相乘函式\n    vector&lt;vector&lt;int&gt;&gt; result = matrixMultiply(matrix1, matrix2);\n\n    // 輸出結果矩陣\n    cout &lt;&lt; &quot;矩陣相乘的結果：&quot; &lt;&lt; endl;\n    for (const auto&amp; row : result) &#123;\n        for (const auto&amp; element : row) &#123;\n            cout &lt;&lt; element &lt;&lt; &quot; &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"矩陣乘向量\"><a class=\"anchor\" href=\"#矩陣乘向量\">#</a> 矩陣乘向量</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 計算矩陣與向量的乘積\nvector&lt;double&gt; matrixVectorMultiply(const vector&lt;vector&lt;double&gt;&gt;&amp; matrix, const vector&lt;double&gt;&amp; vector) &#123;\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n\n    // 檢查矩陣與向量的尺寸是否符合乘法規則\n    if (cols != vector.size()) &#123;\n        cout &lt;&lt; &quot;矩陣與向量的尺寸不符合乘法規則&quot; &lt;&lt; endl;\n        return vector&lt;double&gt;();\n    &#125;\n\n    // 創建結果向量，初始化為零\n    vector&lt;double&gt; result(rows, 0.0);\n\n    // 進行矩陣與向量的乘法\n    for (int i = 0; i &lt; rows; i++) &#123;\n        for (int j = 0; j &lt; cols; j++) &#123;\n            result[i] += matrix[i][j] * vector[j];\n        &#125;\n    &#125;\n\n    return result;\n&#125;\n\n// 測試程式碼\nint main() &#123;\n    // 定義矩陣\n    vector&lt;vector&lt;double&gt;&gt; matrix = &#123;&#123;1, 2, 3&#125;,\n                                     &#123;4, 5, 6&#125;,\n                                     &#123;7, 8, 9&#125;&#125;;\n\n    // 定義向量\n    vector&lt;double&gt; vector = &#123;1, 2, 3&#125;;\n\n    // 計算矩陣與向量的乘積\n    vector&lt;double&gt; result = matrixVectorMultiply(matrix, vector);\n\n    // 輸出結果\n    cout &lt;&lt; &quot;乘積結果：&quot;;\n    for (double value : result) &#123;\n        cout &lt;&lt; value &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n</code></pre>\n",
            "tags": [
                "程式碼"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%B7%9A%E6%80%A7%E4%BB%A3%E6%95%B8/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%B7%9A%E6%80%A7%E4%BB%A3%E6%95%B8/",
            "title": "線性代數",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"求法向量\"><a class=\"anchor\" href=\"#求法向量\">#</a> 求法向量</h1>\n<p>要求一個平面或線的法向量，可以使用幾何或向量運算的方法。法向量是與該平面或線垂直的向量。</p>\n<p>以下是一個簡單的範例來說明如何求一個平面的法向量：</p>\n<p>考慮一個平面的一般方程式：ax + by + cz + d = 0</p>\n<p>根據這個方程式，我們可以觀察到，係數 a、b 和 c 對應於平面的法向量的 x、y 和 z 分量。</p>\n<p>因此，平面的法向量是 N = (a, b, c)。</p>\n<p>這樣，我們就找到了平面的法向量。</p>\n<h1 id=\"線性獨立\"><a class=\"anchor\" href=\"#線性獨立\">#</a> 線性獨立</h1>\n<p>在線性代數中，線性獨立是指一組向量或一組函數的集合，其中沒有一個向量或函數可以表示為其他向量或函數的線性組合。</p>\n<ul>\n<li>換句話說，如果一組向量或函數中的每個成員都 <code>無法由其他成員線性組出</code> ，則該組向量或函數是線性獨立的。</li>\n</ul>\n<p>以下是一個簡單的範例來說明線性獨立的概念：</p>\n<p>考慮二維平面上的兩個向量 v₁ = (1, 0) 和 v₂ = (0, 1)。這兩個向量分別表示 x 軸和 y 軸的單位向量，它們是正交的並且長度為 1。<br />\n現在，我們嘗試用這兩個向量的線性組合來表示另一個向量 v₃ = (2, 3)。假設存在標量 a 和 b，使得 av₁ + bv₂ = v₃。<br />\n將上述等式展開，我們可以得到以下方程組：<br />\na(1, 0) + b(0, 1) = (2, 3)<br />\n 將方程組分解為兩個方程：<br />\na = 2<br />\nb = 3<br />\n 從上面的方程組可以看出，無法找到滿足 a 和 b 的值，使得 av₁ + bv₂ = v₃ 成立。因此，向量 v₃ 無法由向量 v₁ 和 v₂ 的線性組合表示，因此這組向量 {v₁, v₂, v₃} 是線性獨立的。</p>\n<h1 id=\"餘弦相似\"><a class=\"anchor\" href=\"#餘弦相似\">#</a> 餘弦相似</h1>\n<p>餘弦相似（Cosine Similarity）是一種衡量兩個向量之間相似性的度量方法。它基於餘弦定理，通過計算兩個向量之間的夾角來評估它們的相似度。餘弦相似的取值範圍在 -1 到 1 之間，其中值越接近 1，表示兩個向量越相似；值越接近 -1，表示兩個向量越不相似；值為 0 表示兩個向量之間沒有相似性。</p>\n<p>以下是一個簡單的範例來說明餘弦相似的計算：</p>\n<p>假設有兩個二維向量 v₁ = (1, 2) 和 v₂ = (3, 4)。</p>\n<p>首先，計算這兩個向量的內積（dot product）：<br />\nv₁ · v₂ = (1 * 3) + (2 * 4) = 3 + 8 = 11</p>\n<p>接下來，計算每個向量的長度（歐幾里得範數）：<br />\n||v₁|| = √(1² + 2²) = √5 ≈ 2.236<br />\n||v₂|| = √(3² + 4²) = √25 = 5</p>\n<p>然後，計算餘弦相似度：<br />\nsimilarity = v₁ · v₂ / (||v₁|| * ||v₂||) = 11 / (2.236 * 5) ≈ 0.984</p>\n<p>從上述計算結果可以看出，這兩個向量的餘弦相似度約為 0.984，接近於 1，表示它們在方向上非常相似。</p>\n<p>總結：<br />\n餘弦相似是一種用於衡量兩個向量之間相似性的度量方法。它基於餘弦定理，通過計算兩個向量之間的夾角來評估它們的相似度。餘弦相似的取值範圍在 -1 到 1 之間，值越接近 1 表示兩個向量越相似，值越接近 -1 表示兩個向量越不相似，值為 0 表示兩個向量之間沒有相似性。餘弦相似性常用於文本相似度計算、推薦系統、資訊檢索等領域。</p>\n<h1 id=\"一個方陣要怎麼求反矩陣\"><a class=\"anchor\" href=\"#一個方陣要怎麼求反矩陣\">#</a> 一個方陣要怎麼求反矩陣</h1>\n<ol>\n<li>高斯 - 喬登消去法（Gaussian-Jordan elimination）<br />\na. 將右邊放上基本矩陣<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center center center center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>d</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>g</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>h</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>i</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>j</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\n\\begin{bmatrix}\n a &amp; b &amp; c &amp; 1 &amp; 0 &amp; 0 \\\\\n d &amp; f &amp; g &amp; 0 &amp; 1 &amp; 0 \\\\\n h &amp; i &amp; j &amp; 0 &amp; 0 &amp; 1 \n\\end{bmatrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.6em;vertical-align:-1.55em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.05em;\"><span class=\"pstrut\" style=\"height:5.6em;\"></span><span style=\"width:0.667em;height:3.600em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v0 v1759 h84z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">h</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.05em;\"><span class=\"pstrut\" style=\"height:5.6em;\"></span><span style=\"width:0.667em;height:3.600em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v0 v1759 h84z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span></span></span></span></span></li>\n</ol>\n<ul>\n<li>b. 將左邊做列運算至基本矩陣<br />\n c. 可得右邊為反矩陣<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center center center center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mo stretchy=\"false\" lspace=\"0em\" rspace=\"0em\">?</mo></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow><annotation encoding=\"application/x-tex\">\n\\begin{bmatrix}\n  1 &amp; 0 &amp; 0 &amp; ? &amp; ? &amp; ? \\\\\n  0 &amp; 1 &amp; 0 &amp; ? &amp; ? &amp; ? \\\\\n  0 &amp; 0 &amp; 1 &amp; ? &amp; ? &amp; ? \n\\end{bmatrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:3.6em;vertical-align:-1.55em;\"></span><span class=\"minner\"><span class=\"mopen\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.05em;\"><span class=\"pstrut\" style=\"height:5.6em;\"></span><span style=\"width:0.667em;height:3.600em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M403 1759 V84 H666 V0 H319 V1759 v0 v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v0 v1759 h84z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">0</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.21em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-3.01em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span><span style=\"top:-1.81em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mclose\">?</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"delimsizing mult\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:2.05em;\"><span style=\"top:-4.05em;\"><span class=\"pstrut\" style=\"height:5.6em;\"></span><span style=\"width:0.667em;height:3.600em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.667em' height='3.600em' viewBox='0 0 667 3600'><path d='M347 1759 V0 H0 V84 H263 V1759 v0 v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v0 v1759 h84z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.55em;\"><span></span></span></span></span></span></span></span></span></span></span></li>\n<li></li>\n</ul>\n<ol start=\"2\">\n<li>矩陣的伴隨矩陣（adjugate matrix）。</li>\n</ol>\n<p>以下是一個簡單的範例來說明如何求一個方陣的反矩陣：</p>\n<details><summary>2x2的求法</summary><div>\n<p>考慮一個 2x2 的方陣 A：<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo fence=\"true\">[</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence=\"true\">]</mo></mrow></mrow><annotation encoding=\"application/x-tex\">\nA =\n\\begin{bmatrix}\na &amp; b \\\\\nc &amp; d \n\\end{bmatrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"minner\"><span class=\"mopen delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">[</span></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span><span class=\"mclose delimcenter\" style=\"top:0em;\"><span class=\"delimsizing size3\">]</span></span></span></span></span></span></p>\n<p>首先，計算方陣 A 的行列式（determinant）：<br />\ndet(A) = ad - bc</p>\n<p>接下來，計算方陣 A 的伴隨矩陣（adjugate matrix） B：<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>=</mo><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>d</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mo>−</mo><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mo>−</mo><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>a</mi></mstyle></mtd></mtr></mtable></mrow><annotation encoding=\"application/x-tex\">\nB =\n\\begin{matrix}\nd &amp; -b \\\\\n-c &amp; a\n\\end{matrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">−</span><span class=\"mord mathnormal\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">−</span><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n<p>最後，計算反矩陣（inverse matrix） A⁻¹：<br />\nA⁻¹ = (1/det(A)) * B<br />\n= (1/(ad - bc)) * <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mtable rowspacing=\"0.16em\" columnalign=\"center center\" columnspacing=\"1em\"><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>d</mi></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mo>−</mo><mi>b</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mrow><mo>−</mo><mi>c</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel=\"0\" displaystyle=\"false\"><mi>a</mi></mstyle></mtd></mtr></mtable><annotation encoding=\"application/x-tex\">\n\\begin{matrix}\nd &amp; -b \\\\\n-c &amp; a\n\\end{matrix}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.4em;vertical-align:-0.95em;\"></span><span class=\"mord\"><span class=\"mtable\"><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">−</span><span class=\"mord mathnormal\">c</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"arraycolsep\" style=\"width:0.5em;\"></span><span class=\"col-align-c\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.45em;\"><span style=\"top:-3.61em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">−</span><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-2.41em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.95em;\"><span></span></span></span></span></span></span></span></span></span></span></p>\n</div></details>\n",
            "tags": [
                "線性代數"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/",
            "title": "資料結構",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"circular-queue\"><a class=\"anchor\" href=\"#circular-queue\">#</a> Circular Queue</h1>\n<pre><code class=\"language-Mermaid\">\ngraph LR\n    A[A] --&gt; B[B]\n    B --&gt; C[C]\n    C --&gt; D[D]\n    D --&gt; A[A]\n</code></pre>\n<p>一般的隊列（Queue）:FIFO</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">Queue</th>\n<th style=\"text-align:center\">Circular Queue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">資料排列方式</td>\n<td style=\"text-align:center\">線性順序排列</td>\n<td style=\"text-align:center\">循環順序排列，即將尾端和前端連接起來</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入和刪除操作</td>\n<td style=\"text-align:center\">刪除操作都在前端進行<br>插入操作都在尾端進行</td>\n<td style=\"text-align:center\">插入和刪除操作不固定<br>可以在任何位置進行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">記憶體空間</td>\n<td style=\"text-align:center\">更多</td>\n<td style=\"text-align:center\">較少</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">效率</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"dfs-and-bfs\"><a class=\"anchor\" href=\"#dfs-and-bfs\">#</a> DFS and BFS</h1>\n<p><strong>深度優先搜尋 (Depth-First Search, DFS)</strong> 是一種用於搜尋圖或樹數據結構中所有頂點的遞迴演算法。</p>\n<p>例如，假設我們有一個圖 G，它的節點是 {0, 1, 2, 3}，邊是 {(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)}。我們可以從節點 2 開始進行深度優先搜尋。首先，我們訪問節點 2，然後將其相鄰的未訪問節點（0 和 3）放入堆疊。接著，我們訪問堆疊頂部的節點（0），並將其相鄰的未訪問節點（1）放入堆疊。然後，我們訪問堆疊頂部的節點（1），並將其相鄰的未訪問節點（2）放入堆疊。最後，我們訪問堆疊頂部的節點（3）。由於沒有更多的未訪問節點，所以我們的深度優先搜尋結束。</p>\n<p><strong>廣度優先搜尋 (Breadth-First Search, BFS)</strong></p>\n<p>在 BFS 中，從起點節點開始，逐層地擴展搜索，先探索所有與起點節點相鄰的節點，然後再逐層探索與這些節點相鄰的節點，以此類推。</p>\n<p>BFS 使用一個稱為 ** 佇列（Queue）** 的資料結構來維護待處理的節點。</p>\n<ol>\n<li>將起點節點放入佇列中。</li>\n<li>從佇列中取出一個節點，將其標記為已訪問，並擴展搜索到該節點相鄰的未訪問節點，將這些節點加入佇列中。</li>\n</ol>\n<p><strong>重複</strong>這個過程，直到佇列中沒有未訪問的節點為止。</p>\n<p>BFS 的特點是以<strong>廣度</strong>作為搜索的優先順序。也就是說，BFS 先搜索距離起點節點最近的節點，然後再搜索稍遠一些的節點。這意味著，當使用 BFS 搜索時，可以找到從起點到目標節點的最短路徑（如果存在）。</p>\n<p>BFS 可以用在圖形算法、迷宮解決、最短路徑問題等。它確保在搜索過程中先處理較近的節點，因此通常用於找尋最短路徑或尋找圖形中的最短距離。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">DFS</th>\n<th style=\"text-align:center\">BFS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">使用的資料結構</td>\n<td style=\"text-align:center\">Stack</td>\n<td style=\"text-align:center\">Quene</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">順序</td>\n<td style=\"text-align:center\">不唯一 (若 vertex 從小到大拜訪則唯一)</td>\n<td style=\"text-align:center\">不唯一</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"雜湊函數-hash-function\"><a class=\"anchor\" href=\"#雜湊函數-hash-function\">#</a> 雜湊函數 (Hash Function)</h1>\n<p><strong>雜湊函數 (Hash Function)</strong> 是一種數學函數，它將任意大小的輸入數據（稱為 “資料”）轉換為固定大小的輸出字串（稱為 “雜湊值”）。</p>\n<p>例如我們將  <code>Hello World!</code>  的字串分別用 MD5、SHA1、SHA256<br />\nMD5:  <code>ed076287532e86365e841e92bfc50d8c</code> <br />\nSHA1:  <code>2ef7bde608ce5404e97d5f042f95f89f1c232871</code> <br />\nSHA256:  <code>7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069</code></p>\n<ul>\n<li>雜湊函數會希望是不可逆</li>\n<li>雜湊函數可能會有相同的情況 (碰撞)</li>\n<li>原始資料有小變動，則希望雜湊值更大的變化</li>\n</ul>\n",
            "tags": [
                "資料結構"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%9B%A2%E6%95%A3%E6%95%B8%E5%AD%B8/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%9B%A2%E6%95%A3%E6%95%B8%E5%AD%B8/",
            "title": "離散數學",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"背包問題\"><a class=\"anchor\" href=\"#背包問題\">#</a> 背包問題</h1>\n<p>背包問題（Knapsack Problem）是一個經典的優化問題，屬於組合優化問題的一種，有一個固定容量的背包和一組具有不同價值和重量的物品，我們需要在限制背包容量的條件下，選擇最佳的物品組合，使得<strong>總價值最大化</strong>，可以使用<strong>動態規劃</strong>、<strong>貪婪算法</strong>來找到最佳解。</p>\n<p>背包問題可以分為兩種主要的變體：</p>\n<ol>\n<li>0/1 背包問題（0/1 Knapsack Problem）：每個物品要麼全部放入背包，要麼完全不放入背包，<strong>無法將物品分割</strong>為部分放入。</li>\n<li>分數背包問題（Fractional Knapsack Problem）：每個物品<strong>可以按比例分割</strong>，可以將物品的一部分放入背包。</li>\n</ol>\n<p>假設有一個可放入總重量為 10 的背包，我們有以下物品可供選擇：</p>\n<ul>\n<li>物品 1：價值 60，重量 4，價值 / 重量 = 15</li>\n<li>物品 2：價值 80，重量 5，價值 / 重量 = 16</li>\n<li>物品 3：價值 100，重量 8，價值 / 重量 = 12.5</li>\n</ul>\n<ol>\n<li>0/1 背包問題：</li>\n</ol>\n<p>最佳的物品組合是將物品 2 和物品 1 放入背包，總價值為 140。</p>\n<ol start=\"2\">\n<li>分數背包問題：</li>\n</ol>\n<p>最佳的物品組合是將物品 2 和物品 1 完全放入背包，物品 3 的一部分（重量為 1）放入背包，總價值為 152.5。<br />\n這是因為物品 2 的價值重量比最高，而物品 1 的價值重量比次之，物品 3 的價值重量比最低，<br />\n因此我們先選取物品 2 和物品 1，再選取物品 3 的一部分。</p>\n<h1 id=\"尤拉函數\"><a class=\"anchor\" href=\"#尤拉函數\">#</a> 尤拉函數</h1>\n<p>尤拉函數（Euler's function），也稱為歐拉函數或歐拉 φ 函數。</p>\n<ul>\n<li>用來計算小於或等於給定正整數的自然數中與該正整數 <code>互質</code> 的數的個數。</li>\n</ul>\n<p>尤拉函數的符號表示為 φ(n)，其中 n 是一個正整數。<br />\n尤拉函數的計算方法基於歐拉定理，它指出若 a 和 n 是互質的正整數，則 a 的尤拉函數值 φ(n) 等於小於或等於 n 的正整數中與 n 互質的數的個數。</p>\n<p>範例：</p>\n<p>假設我們要計算 φ(8)。首先，列出小於或等於 8 的正整數：1、2、3、4、5、6、7、8。<br />\n然後，我們找出與 8 互質的數，即與 8 沒有共同因數的數。<br />\n在這個例子中，與 8 互質的數有：1、3、5、7。因此，φ(8) = 4，表示小於或等於 8 的正整數中，有 4 個與 8 互質的數。</p>\n",
            "tags": [
                "離散數學"
            ]
        },
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%A1%8C%E7%9B%AE/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%A1%8C%E7%9B%AE/",
            "title": "程式題目",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"印星星\"><a class=\"anchor\" href=\"#印星星\">#</a> 印星星</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid printUpperTriangle(int n) &#123;\n    for (int i = 0; i &lt; n; i++) &#123;\n        for (int j = 0; j &lt;= i; j++) &#123;\n            cout &lt;&lt; &quot;* &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n\nvoid printLowerTriangle(int n) &#123;\n    for (int i = n; i &gt; 0; i--) &#123;\n        for (int j = 0; j &lt; i; j++) &#123;\n            cout &lt;&lt; &quot;* &quot;;\n        &#125;\n        cout &lt;&lt; endl;\n    &#125;\n&#125;\n\nint main() &#123;\n    int n;\n    cout &lt;&lt; &quot;請輸入行數: &quot;;\n    cin &gt;&gt; n;\n\n    cout &lt;&lt; &quot;上三角形：&quot; &lt;&lt; endl;\n    printUpperTriangle(n);\n\n    cout &lt;&lt; &quot;下三角形：&quot; &lt;&lt; endl;\n    printLowerTriangle(n);\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"用遞迴寫階乘\"><a class=\"anchor\" href=\"#用遞迴寫階乘\">#</a> 用遞迴寫階乘</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\n// 定義遞迴函式計算階乘\nint factorial(int n) &#123;\n    // Base case: 當 n 為 0 或 1 時，階乘為 1\n    if (n == 0 || n == 1) &#123;\n        return 1;\n    &#125;\n    // 遞迴呼叫：將問題分解為較小的子問題\n    // 階乘 n 可以表示為 n 乘上 (n-1) 的階乘\n    return n * factorial(n - 1);\n&#125;\n\nint main() &#123;\n    int num;\n    cout &lt;&lt; &quot;請輸入一個正整數: &quot;;\n    cin &gt;&gt; num;\n\n    // 呼叫遞迴函式計算階乘\n    int result = factorial(num);\n\n    cout &lt;&lt; num &lt;&lt; &quot; 的階乘是: &quot; &lt;&lt; result &lt;&lt; endl;\n\n    return 0;\n&#125;\n</code></pre>\n<h1 id=\"找出陣列中第二大的數字\"><a class=\"anchor\" href=\"#找出陣列中第二大的數字\">#</a> 找出陣列中第二大的數字</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint findSecondLargest(int arr[], int size) &#123;\n    int largest = INT_MIN;  // 初始化最大值為int類型的最小值\n    int secondLargest = INT_MIN;  // 初始化第二大值為int類型的最小值\n\n    // 遍歷數組，更新最大值和第二大值\n    for (int i = 0; i &lt; size; i++) &#123;\n        if (arr[i] &gt; largest) &#123;\n            secondLargest = largest;\n            largest = arr[i];\n        &#125; else if (arr[i] &gt; secondLargest &amp;&amp; arr[i] != largest) &#123;\n            secondLargest = arr[i];\n        &#125;\n    &#125;\n\n    return secondLargest;\n&#125;\n\nint main() &#123;\n    int arr[] = &#123;5, 2, 9, 1, 7, 4&#125;;  // 範例數組\n    int size = sizeof(arr) / sizeof(arr[0]);  // 計算數組大小\n\n    // 調用函數找到第二大的數\n    int secondLargest = findSecondLargest(arr, size);\n\n    cout &lt;&lt; &quot;第二大的數字是: &quot; &lt;&lt; secondLargest &lt;&lt; endl;\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"給定一數字找出因數\"><a class=\"anchor\" href=\"#給定一數字找出因數\">#</a> 給定一數字，找出因數</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// 找出給定數字的因數\nvector&lt;int&gt; findFactors(int num) &#123;\n    vector&lt;int&gt; factors;\n\n    // 從 1 開始遍歷到 num 的平方根\n    for (int i = 1; i * i &lt;= num; i++) &#123;\n        if (num % i == 0) &#123;\n            factors.push_back(i); // 將因數 i 加入 factors\n            if (i != num / i) &#123;\n                factors.push_back(num / i); // 將因數 num/i 加入 factors\n            &#125;\n        &#125;\n    &#125;\n\n    return factors;\n&#125;\n\nint main() &#123;\n    int num;\n    cout &lt;&lt; &quot;請輸入一個正整數：&quot;;\n    cin &gt;&gt; num;\n\n    vector&lt;int&gt; factors = findFactors(num);\n\n    cout &lt;&lt; num &lt;&lt; &quot; 的因數有：&quot;;\n    for (int factor : factors) &#123;\n        cout &lt;&lt; factor &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; endl;\n\n    return 0;\n&#125;\n</code></pre>\n<h1 id=\"判斷質數\"><a class=\"anchor\" href=\"#判斷質數\">#</a> 判斷質數</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nusing namespace std;\n\n// 判斷一個數字是否為質數\nbool isPrime(int number) &#123;\n    // 負數和小於等於 1 的數字不是質數\n    if (number &lt;= 1) &#123;\n        return false;\n    &#125;\n\n    // 使用平方根的方法進行質數判斷\n    // 如果一個數字 n 是合數（非質數）\n    // 那麼它必定可以分解為兩個因數 a 和 b\n    // 其中 a 和 b 都不大於 sqrt(n)\n    int sqrtNumber = sqrt(number);\n    for (int i = 2; i &lt;= sqrtNumber; i++) &#123;\n        if (number % i == 0) &#123;\n            return false;\n        &#125;\n    &#125;\n\n    // 如果沒有找到能整除 number 的數字，則 number 是質數\n    return true;\n&#125;\n\n// 測試程式碼\nint main() &#123;\n    int number;\n\n    cout &lt;&lt; &quot;請輸入一個數字：&quot;;\n    cin &gt;&gt; number;\n\n    // 呼叫 isPrime 函式判斷是否為質數\n    bool result = isPrime(number);\n\n    // 根據結果輸出訊息\n    if (result) &#123;\n        cout &lt;&lt; number &lt;&lt; &quot; 是質數&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; number &lt;&lt; &quot; 不是質數&quot; &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<h1 id=\"判斷子字串\"><a class=\"anchor\" href=\"#判斷子字串\">#</a> 判斷子字串</h1>\n<pre><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// 判斷一個字串是否為另一個字串的子字串\nbool isSubstring(const string&amp; str, const string&amp; substring) &#123;\n    // 如果子字串長度大於原始字串，則直接返回 false\n    if (substring.length() &gt; str.length()) &#123;\n        return false;\n    &#125;\n\n    // 遍歷原始字串，逐個比較字元\n    for (size_t i = 0; i &lt;= str.length() - substring.length(); i++) &#123;\n        bool isMatch = true;\n\n        // 檢查子字串是否匹配\n        for (size_t j = 0; j &lt; substring.length(); j++) &#123;\n            if (str[i + j] != substring[j]) &#123;\n                isMatch = false;\n                break;\n            &#125;\n        &#125;\n\n        // 如果子字串匹配，則返回 true\n        if (isMatch) &#123;\n            return true;\n        &#125;\n    &#125;\n\n    // 沒有找到匹配的子字串，返回 false\n    return false;\n&#125;\n\n// 測試程式碼\nint main() &#123;\n    string str, substring;\n\n    cout &lt;&lt; &quot;請輸入一個字串：&quot;;\n    getline(cin, str);\n\n    cout &lt;&lt; &quot;請輸入一個子字串：&quot;;\n    getline(cin, substring);\n\n    // 呼叫 isSubstring 函式判斷是否為子字串\n    bool result = isSubstring(str, substring);\n\n    // 根據結果輸出訊息\n    if (result) &#123;\n        cout &lt;&lt; &quot;\\\\&quot;&quot; &lt;&lt; substring &lt;&lt; &quot;\\\\&quot; 是 \\\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\\\&quot; 的子字串&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;\\\\&quot;&quot; &lt;&lt; substring &lt;&lt; &quot;\\\\&quot; 不是 \\\\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\\\&quot; 的子字串&quot; &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<ul>\n<li>使用迴圈逐個比較字元的方式來實現。</li>\n</ul>\n<ol>\n<li>\n<p>檢查子字串的長度是否大於原始字串的長度，如果是，則直接返回 false，因為子字串不可能是原始字串的子字串。</p>\n</li>\n<li>\n<p>使用兩個嵌套的迴圈。外層迴圈遍歷原始字串，內層迴圈檢查從當前位置開始的子字串是否匹配。如果在內層迴圈中找到了不匹配的字元，則設置  <code>isMatch</code>  為 false，並且跳出內層迴圈。</p>\n</li>\n</ol>\n",
            "tags": [
                "程式碼"
            ]
        }
    ]
}