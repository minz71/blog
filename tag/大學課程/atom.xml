<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.minz.li</id>
    <title>minz的筆記本 • Posts by &#34;大學課程&#34; tag</title>
    <link href="https://blog.minz.li" />
    <updated>2023-11-01T16:00:00.000Z</updated>
    <category term="domain" />
    <category term="madVR" />
    <category term="API" />
    <category term="DevOps" />
    <category term="Docker" />
    <category term="WSL" />
    <category term="UiPath" />
    <category term="Netflix" />
    <category term="Netflix共享" />
    <category term="ShokaX主題" />
    <category term="ShokaX插件" />
    <category term="ShokaX" />
    <category term="llm" />
    <category term="LMSYS" />
    <category term="物件導向" />
    <category term="大學課程" />
    <category term="程式碼" />
    <category term="機率與統計" />
    <category term="演算法" />
    <category term="線性代數" />
    <category term="資料結構" />
    <category term="離散數學" />
    <entry>
        <id>https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/</id>
        <title>作業系統</title>
        <link rel="alternate" href="https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/"/>
        <content type="html">&lt;h1 id=&#34;race-condition-是什麼&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#race-condition-是什麼&#34;&gt;#&lt;/a&gt; Race Condition 是什麼？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;競爭條件 (Race Condition)&lt;/strong&gt; 是當兩個或多個異步運行的程式碼（例如，中斷和背景迴圈）更改 &lt;strong&gt;共享資源 (Share Resource)&lt;/strong&gt; 時會發生的情況。&lt;/p&gt;
&lt;p&gt;例如，假設我們有兩個 Process A 和 B，都想要訪問同一個共享變量。如果 A 和 B 都嘗試在同一時間讀取和修改這個變量，那麼就&lt;strong&gt;可能&lt;/strong&gt;會產生競爭條件。&lt;br /&gt;
如果沒有提供&lt;strong&gt;互斥存取&lt;/strong&gt;，我們&lt;strong&gt;無法確定&lt;/strong&gt; A 和 B 的執行順序，所以最終的結果可能會有所&lt;strong&gt;不同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;解決方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鎖 (Locks)&lt;/li&gt;
&lt;li&gt;原子變量 (Atomic Variables)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;同步-synchronization&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#同步-synchronization&#34;&gt;#&lt;/a&gt; 同步 (Synchronization)&lt;/h1&gt;
&lt;p&gt;主要目的是確保多個進程訪問共享資源時不會互相干擾，並防止由於並發訪問而可能產生的數據不一致&lt;/p&gt;
&lt;p&gt;為了實現這一點，我們可以使用各種同步技術，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信號量（semaphores）&lt;/li&gt;
&lt;li&gt;監視器（monitors）&lt;/li&gt;
&lt;li&gt;臨界區（critical sections）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，有兩個進程 A 和 B，它們都想要訪問同一個共享變數 (share variable)。&lt;/p&gt;
&lt;h2 id=&#34;信號量semaphores&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#信號量semaphores&#34;&gt;#&lt;/a&gt; 信號量（semaphores）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;我們可以初始化一個信號量並將其設置為 1。&lt;/li&gt;
&lt;li&gt;當進程 A 想要訪問共享變量時，它會先減少信號量的值。&lt;/li&gt;
&lt;li&gt;如果信號量的值大於等於 0，那麼 A 可以繼續執行並訪問共享變量。&lt;/li&gt;
&lt;li&gt;否則，A 將被阻塞並等待。&lt;/li&gt;
&lt;li&gt;當 A 完成對共享變量的訪問後，它會增加信號量的值，這可能會喚醒等待的進程 B2&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;span&gt;信號量（semaphores）&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;mutex semaphore &lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token boolean&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// 檢查 &gt; 0 通過並 - 1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        臨界區程式碼&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token function&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;mutex&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;// 離開時 + 1&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        臨界區以外程式碼&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;臨界區critical-sections&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#臨界區critical-sections&#34;&gt;#&lt;/a&gt; 臨界區（critical sections）&lt;/h2&gt;
&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;figcaption data-lang=&#34;C++&#34;&gt;&lt;span&gt;臨界區（critical sections）&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token comment&#34;&gt;// 臨界區指的是有使用共享變數之區塊&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token boolean&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;進入區段&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        臨界區程式碼&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;離開區段&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        臨界區以外程式碼&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span class=&#34;token punctuation&#34;&gt;&amp;#125;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&#34;process和thread&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#process和thread&#34;&gt;#&lt;/a&gt; Process 和 Thread&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;程序 (Process)&lt;/strong&gt; 和 &lt;strong&gt;線程 (Thread)&lt;/strong&gt; 是兩種不同的執行實體，都是 CPU 調度和執行的基本單位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process&lt;/strong&gt; 有 Process Control Block (PCB)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PID&lt;/li&gt;
&lt;li&gt;程式計數器 (Program counter)&lt;/li&gt;
&lt;li&gt;CPU 暫存器內容&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;Code 區段&lt;/li&gt;
&lt;li&gt;Data 區段&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;&lt;strong&gt;Thread&lt;/strong&gt; 是一個半進程，它有自己的堆疊並執行一段給定的代碼。&lt;br&gt;與真正的進程不同，&lt;strong&gt;線程通常與其他線程共享其記憶體&lt;/strong&gt;。&lt;br /&gt;
進程通常對每一個都有一個不同的記憶體區域。&lt;strong&gt;一個進程可以有多個線程在運行&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例如，假設我們有一個文字處理器程式。&lt;br /&gt;
該程式可能有&lt;strong&gt;一個主 Process&lt;/strong&gt; 負責管理用戶界面，&lt;br /&gt;
以及&lt;strong&gt;多個線程&lt;/strong&gt;負責處理後台任務，如保存文件、檢查拼寫和語法等。&lt;/p&gt;
&lt;h1 id=&#34;content-switch-是什麼&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#content-switch-是什麼&#34;&gt;#&lt;/a&gt; Content Switch 是什麼？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Context Switch&lt;/strong&gt;（上下文切換）是一種系統事件，使得單個 CPU 能夠被多個進程共享的重要機制，它允許作業系統在多個進程之間進行切換，使得每個進程都有機會使用 CPU 來完成其執行。&lt;/p&gt;
&lt;div class=&#34;note info&#34;&gt;
&lt;p&gt;例如，假設我們有兩個進程 A 和 B。A 正在 CPU 上運行，而 B 在等待 CPU。當作業系統決定讓 B 運行時，它會進行上下文切換。&lt;/p&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;保存 A 的當前狀態（包括程序計數器、暫存器的值等），&lt;/li&gt;
&lt;li&gt;然後加載 B 的狀態並讓 B 運行。&lt;/li&gt;
&lt;li&gt;當要讓 A 再次運行時，作業系統會再次進行上下文切換，恢復 A 的狀態並讓 A 運行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;deadlock&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deadlock&#34;&gt;#&lt;/a&gt; DeadLock&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Mutual exlusion 互斥存取&lt;/li&gt;
&lt;li&gt;Hold &amp;amp; Wait 拿了其他 Process 需要的資源並等待&lt;/li&gt;
&lt;li&gt;No preemption 不搶佔&lt;/li&gt;
&lt;li&gt;Circular wait 循環等待&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="大學課程" />
        <updated>2023-11-01T16:00:00.000Z</updated>
    </entry>
</feed>
