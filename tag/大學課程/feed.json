{
    "version": "https://jsonfeed.org/version/1",
    "title": "minz的筆記本 • All posts by \"大學課程\" tag",
    "description": "",
    "home_page_url": "https://blog.minz.li",
    "items": [
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "title": "作業系統",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"race-condition-是什麼\"><a class=\"anchor\" href=\"#race-condition-是什麼\">#</a> Race Condition 是什麼？</h1>\n<p><strong>競爭條件 (Race Condition)</strong> 兩個或兩個以上的進程或線程在更改 <strong>共享資源 (Share Resource)</strong> 時會發生的情況。</p>\n<p>例如，假設我們有兩個 Process A 和 B，都想要訪問同一個共享變量。<br />\n如果 A 和 B 都嘗試在同一時間讀取和修改這個變量，那麼就<strong>可能</strong>會產生競爭條件。<br />\n如果沒有提供<strong>互斥存取</strong>，我們<strong>無法確定</strong> A 和 B 的執行順序，所以最終的結果可能會有所<strong>不同</strong>。</p>\n<p>解決方式:</p>\n<ul>\n<li>鎖 (Locks)</li>\n<li>原子變量 (Atomic Variables)</li>\n</ul>\n<h1 id=\"同步-synchronization\"><a class=\"anchor\" href=\"#同步-synchronization\">#</a> 同步 (Synchronization)</h1>\n<p>主要目的是確保多個進程訪問共享資源時不會互相干擾，並防止由於並發訪問而可能產生的數據不一致</p>\n<p>為了實現這一點，我們可以使用各種同步技術，</p>\n<ul>\n<li>信號量（semaphores）</li>\n<li>監視器（monitors）</li>\n<li>臨界區（critical sections）</li>\n</ul>\n<p>例如，有兩個進程 A 和 B，它們都想要訪問同一個共享變數 (share variable)。</p>\n<h2 id=\"信號量semaphores\"><a class=\"anchor\" href=\"#信號量semaphores\">#</a> 信號量（semaphores）</h2>\n<ul>\n<li>我們可以初始化一個信號量並將其設置為 1。</li>\n<li>當進程 A 想要訪問共享變量時，它會先減少信號量的值。</li>\n<li>如果信號量的值大於等於 0，那麼 A 可以繼續執行並訪問共享變量。</li>\n<li>否則，A 將被阻塞並等待。</li>\n<li>當 A 完成對共享變量的訪問後，它會增加信號量的值，這可能會喚醒等待的進程 B</li>\n</ul>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>信號量（semaphores）</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mutex semaphore <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 檢查 > 0 通過並 - 1</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        臨界區程式碼<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 離開時 + 1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        臨界區以外程式碼<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"臨界區critical-sections\"><a class=\"anchor\" href=\"#臨界區critical-sections\">#</a> 臨界區（critical sections）</h2>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>臨界區（critical sections）</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 臨界區指的是有使用共享變數之區塊</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">(</span>進入區段<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        臨界區程式碼<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token punctuation\">(</span>離開區段<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        臨界區以外程式碼<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h1 id=\"process-和-thread\"><a class=\"anchor\" href=\"#process-和-thread\">#</a> Process 和 Thread</h1>\n<p><strong>程序 (Process)</strong> 和 <strong>線程 (Thread)</strong> 是兩種不同的執行實體，都是 CPU 調度和執行的基本單位。</p>\n<p><strong>Process</strong> 有 Process Control Block (PCB)。</p>\n<ol>\n<li>PID</li>\n<li>程式計數器 (Program counter)</li>\n<li>CPU 暫存器內容</li>\n<li>Stack</li>\n<li>Code 區段</li>\n<li>Data 區段</li>\n<li>Heap</li>\n</ol>\n<div class=\"note info\">\n<p><strong>Thread</strong> 是一個半進程，它有自己的堆疊並執行一段給定的代碼。<br>與真正的進程不同，<strong>線程通常與其他線程共享其記憶體</strong>。<br />\n包括 Code 區段、Data 區段、Heap 等。進程通常對每一個都有一個不同的記憶體區域，但進程中的多個線程共享同一個記憶體空間。一個進程可以有多個線程在運行。</p>\n</div>\n<p>例如，假設我們有一個文字處理器程式。<br />\n該程式可能有<strong>一個主 Process</strong> 負責管理用戶界面，<br />\n以及<strong>多個線程</strong>負責處理後台任務，如保存文件、檢查拼寫和語法等。</p>\n<h1 id=\"context-switch-是什麼\"><a class=\"anchor\" href=\"#context-switch-是什麼\">#</a> Context Switch 是什麼？</h1>\n<p><strong>Context Switch</strong>（上下文切換）是一種系統事件，使得單個 CPU 能夠被多個進程共享的重要機制，它允許作業系統在多個進程之間進行切換，使得每個進程都有機會使用 CPU 來完成其執行。</p>\n<div class=\"note info\">\n<p>例如，假設我們有兩個進程 A 和 B。<br />\nA 正在 CPU 上運行，而 B 在等待 CPU。當作業系統決定讓 B 運行時，它會進行上下文切換。</p>\n</div>\n<ol>\n<li>保存 A 的當前狀態（包括程序計數器、暫存器的值等），</li>\n<li>然後加載 B 的狀態並讓 B 運行。</li>\n<li>當要讓 A 再次運行時，作業系統會再次進行上下文切換，恢復 A 的狀態並讓 A 運行。</li>\n</ol>\n<h1 id=\"deadlock-需要滿足的-4-個條件\"><a class=\"anchor\" href=\"#deadlock-需要滿足的-4-個條件\">#</a> DeadLock 需要滿足的 4 個條件</h1>\n<ol>\n<li>Mutual exlusion（互斥存取） :<br />\n 資源不能被多個進程同時使用。</li>\n<li>Hold &amp; Wait（持有和等待）:<br />\n 一個 Process 持有至少一個資源，同時在等待獲取額外的資源，而該資源又被其他 Process 持有。</li>\n<li>No preemption（不搶佔） :<br />\n 已被持有的資源在進程使用完之前不能被強制奪取，除非該進程自願釋放資源。<br />\n如果系統可以強制奪取資源，就可以避免死結，但這可能會導致其他問題，如飢餓或優先權反轉。</li>\n<li>Circular wait（循環等待） :<br />\n 存在一個進程集合 {P1, P2, ..., PN}，其中 P1 正在等待 P2 持有的資源，P2 正在等待 P3 持有的資源，以此類推，最後 PN 正在等待 P1 持有的資源，形成一個循環等待的閉鎖環。</li>\n</ol>\n<p>這些條件是導致死結的必要條件，但不是充分條件。<br />\n也就是說，如果系統中存在這些條件，死結就有<strong>可能</strong>發生，但不一定會發生。</p>\n",
            "tags": [
                "大學課程"
            ]
        }
    ]
}