{
    "version": "https://jsonfeed.org/version/1",
    "title": "minz的筆記本 • All posts by \"大學課程\" tag",
    "description": "~~~~~~~",
    "home_page_url": "https://blog.minz.li",
    "items": [
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1/",
            "title": "作業系統",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"race-condition-是什麼\"><a class=\"anchor\" href=\"#race-condition-是什麼\">#</a> Race Condition 是什麼？</h1>\n<p><strong>競爭條件 (Race Condition)</strong> 是當兩個或多個異步運行的程式碼（例如，中斷和背景迴圈）更改 <strong>共享資源 (Share Resource)</strong> 時會發生的情況。</p>\n<p>例如，假設我們有兩個 Process A 和 B，都想要訪問同一個共享變量。如果 A 和 B 都嘗試在同一時間讀取和修改這個變量，那麼就<strong>可能</strong>會產生競爭條件。<br />\n如果沒有提供<strong>互斥存取</strong>，我們<strong>無法確定</strong> A 和 B 的執行順序，所以最終的結果可能會有所<strong>不同</strong>。</p>\n<p>解決方式:</p>\n<ul>\n<li>鎖 (Locks)</li>\n<li>原子變量 (Atomic Variables)</li>\n</ul>\n<h1 id=\"同步-synchronization\"><a class=\"anchor\" href=\"#同步-synchronization\">#</a> 同步 (Synchronization)</h1>\n<p>主要目的是確保多個進程訪問共享資源時不會互相干擾，並防止由於並發訪問而可能產生的數據不一致</p>\n<p>為了實現這一點，我們可以使用各種同步技術，</p>\n<ul>\n<li>信號量（semaphores）</li>\n<li>監視器（monitors）</li>\n<li>臨界區（critical sections）</li>\n</ul>\n<p>例如，有兩個進程 A 和 B，它們都想要訪問同一個共享變數 (share variable)。</p>\n<h2 id=\"信號量semaphores\"><a class=\"anchor\" href=\"#信號量semaphores\">#</a> 信號量（semaphores）</h2>\n<ul>\n<li>我們可以初始化一個信號量並將其設置為 1。</li>\n<li>當進程 A 想要訪問共享變量時，它會先減少信號量的值。</li>\n<li>如果信號量的值大於等於 0，那麼 A 可以繼續執行並訪問共享變量。</li>\n<li>否則，A 將被阻塞並等待。</li>\n<li>當 A 完成對共享變量的訪問後，它會增加信號量的值，這可能會喚醒等待的進程 B2</li>\n</ul>\n<pre><code class=\"language-C++\">mutex semaphore = 1;\nwhile(true)&#123;\n    wait(mutex); // 檢查&gt;0通過並-1\n        臨界區程式碼...\n    signal(mutex); // 離開時+1\n        臨界區以外程式碼...\n&#125;\n</code></pre>\n<h2 id=\"臨界區critical-sections\"><a class=\"anchor\" href=\"#臨界區critical-sections\">#</a> 臨界區（critical sections）</h2>\n<pre><code class=\"language-C++\">// 臨界區指的是有使用共享變數之區塊\nwhile(true)&#123;\n    (進入區段)\n        臨界區程式碼...\n    (離開區段)\n        臨界區以外程式碼...\n&#125;\n\n</code></pre>\n<h1 id=\"process和thread\"><a class=\"anchor\" href=\"#process和thread\">#</a> Process 和 Thread</h1>\n<p><strong>程序 (Process)</strong> 和 <strong>線程 (Thread)</strong> 是兩種不同的執行實體，都是 CPU 調度和執行的基本單位。</p>\n<p><strong>Process</strong> 有 Process Control Block (PCB)。</p>\n<ol>\n<li>PID</li>\n<li>程式計數器 (Program counter)</li>\n<li>CPU 暫存器內容</li>\n<li>Stack</li>\n<li>Code 區段</li>\n<li>Data 區段</li>\n<li>Heap</li>\n</ol>\n<div class=\"note info\">\n<p><strong>Thread</strong> 是一個半進程，它有自己的堆疊並執行一段給定的代碼。<br>與真正的進程不同，<strong>線程通常與其他線程共享其記憶體</strong>。<br />\n進程通常對每一個都有一個不同的記憶體區域。<strong>一個進程可以有多個線程在運行</strong>。</p>\n</div>\n<p>例如，假設我們有一個文字處理器程式。<br />\n該程式可能有<strong>一個主 Process</strong> 負責管理用戶界面，<br />\n以及<strong>多個線程</strong>負責處理後台任務，如保存文件、檢查拼寫和語法等。</p>\n<h1 id=\"content-switch-是什麼\"><a class=\"anchor\" href=\"#content-switch-是什麼\">#</a> Content Switch 是什麼？</h1>\n<p><strong>Context Switch</strong>（上下文切換）是一種系統事件，使得單個 CPU 能夠被多個進程共享的重要機制，它允許作業系統在多個進程之間進行切換，使得每個進程都有機會使用 CPU 來完成其執行。</p>\n<div class=\"note info\">\n<p>例如，假設我們有兩個進程 A 和 B。A 正在 CPU 上運行，而 B 在等待 CPU。當作業系統決定讓 B 運行時，它會進行上下文切換。</p>\n</div>\n<ol>\n<li>保存 A 的當前狀態（包括程序計數器、暫存器的值等），</li>\n<li>然後加載 B 的狀態並讓 B 運行。</li>\n<li>當要讓 A 再次運行時，作業系統會再次進行上下文切換，恢復 A 的狀態並讓 A 運行。</li>\n</ol>\n<h1 id=\"deadlock\"><a class=\"anchor\" href=\"#deadlock\">#</a> DeadLock</h1>\n<ol>\n<li>Mutual exlusion 互斥存取</li>\n<li>Hold &amp; Wait 拿了其他 Process 需要的資源並等待</li>\n<li>No preemption 不搶佔</li>\n<li>Circular wait 循環等待</li>\n</ol>\n",
            "tags": [
                "大學課程"
            ]
        }
    ]
}