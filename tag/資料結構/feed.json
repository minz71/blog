{
    "version": "https://jsonfeed.org/version/1",
    "title": "minz的筆記本 • All posts by \"資料結構\" tag",
    "description": "心得分享",
    "home_page_url": "https://blog.minz.li",
    "items": [
        {
            "id": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/",
            "url": "https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/",
            "title": "資料結構",
            "date_published": "2023-11-01T16:00:00.000Z",
            "content_html": "<h1 id=\"circular-queue\"><a class=\"anchor\" href=\"#circular-queue\">#</a> Circular Queue</h1>\n<pre><code class=\"language-Mermaid\">\ngraph LR\n    A[A] --&gt; B[B]\n    B --&gt; C[C]\n    C --&gt; D[D]\n    D --&gt; A[A]\n</code></pre>\n<p>一般的隊列（Queue）:FIFO</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">Queue</th>\n<th style=\"text-align:center\">Circular Queue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">資料排列方式</td>\n<td style=\"text-align:center\">線性順序排列</td>\n<td style=\"text-align:center\">循環順序排列，即將尾端和前端連接起來</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">插入和刪除操作</td>\n<td style=\"text-align:center\">刪除操作都在前端進行<br>插入操作都在尾端進行</td>\n<td style=\"text-align:center\">插入和刪除操作不固定<br>可以在任何位置進行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">記憶體空間</td>\n<td style=\"text-align:center\">更多</td>\n<td style=\"text-align:center\">較少</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">效率</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"dfs-and-bfs\"><a class=\"anchor\" href=\"#dfs-and-bfs\">#</a> DFS and BFS</h1>\n<p><strong>深度優先搜尋 (Depth-First Search, DFS)</strong> 是一種用於搜尋圖或樹數據結構中所有頂點的遞迴演算法。</p>\n<p>例如，假設我們有一個圖 G，它的節點是 {0, 1, 2, 3}，邊是 {(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)}。我們可以從節點 2 開始進行深度優先搜尋。首先，我們訪問節點 2，然後將其相鄰的未訪問節點（0 和 3）放入堆疊。接著，我們訪問堆疊頂部的節點（0），並將其相鄰的未訪問節點（1）放入堆疊。然後，我們訪問堆疊頂部的節點（1），並將其相鄰的未訪問節點（2）放入堆疊。最後，我們訪問堆疊頂部的節點（3）。由於沒有更多的未訪問節點，所以我們的深度優先搜尋結束。</p>\n<p><strong>廣度優先搜尋 (Breadth-First Search, BFS)</strong></p>\n<p>在 BFS 中，從起點節點開始，逐層地擴展搜索，先探索所有與起點節點相鄰的節點，然後再逐層探索與這些節點相鄰的節點，以此類推。</p>\n<p>BFS 使用一個稱為 ** 佇列（Queue）** 的資料結構來維護待處理的節點。</p>\n<ol>\n<li>將起點節點放入佇列中。</li>\n<li>從佇列中取出一個節點，將其標記為已訪問，並擴展搜索到該節點相鄰的未訪問節點，將這些節點加入佇列中。</li>\n</ol>\n<p><strong>重複</strong>這個過程，直到佇列中沒有未訪問的節點為止。</p>\n<p>BFS 的特點是以<strong>廣度</strong>作為搜索的優先順序。也就是說，BFS 先搜索距離起點節點最近的節點，然後再搜索稍遠一些的節點。這意味著，當使用 BFS 搜索時，可以找到從起點到目標節點的最短路徑（如果存在）。</p>\n<p>BFS 可以用在圖形算法、迷宮解決、最短路徑問題等。它確保在搜索過程中先處理較近的節點，因此通常用於找尋最短路徑或尋找圖形中的最短距離。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">DFS</th>\n<th style=\"text-align:center\">BFS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">使用的資料結構</td>\n<td style=\"text-align:center\">Stack</td>\n<td style=\"text-align:center\">Quene</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">順序</td>\n<td style=\"text-align:center\">不唯一 (若 vertex 從小到大拜訪則唯一)</td>\n<td style=\"text-align:center\">不唯一</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"雜湊函數-hash-function\"><a class=\"anchor\" href=\"#雜湊函數-hash-function\">#</a> 雜湊函數 (Hash Function)</h1>\n<p><strong>雜湊函數 (Hash Function)</strong> 是一種數學函數，它將任意大小的輸入數據（稱為 “資料”）轉換為固定大小的輸出字串（稱為 “雜湊值”）。</p>\n<p>例如我們將  <code>Hello World!</code>  的字串分別用 MD5、SHA1、SHA256<br />\nMD5:  <code>ed076287532e86365e841e92bfc50d8c</code> <br />\nSHA1:  <code>2ef7bde608ce5404e97d5f042f95f89f1c232871</code> <br />\nSHA256:  <code>7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069</code></p>\n<ul>\n<li>雜湊函數會希望是不可逆</li>\n<li>雜湊函數可能會有相同的情況 (碰撞)</li>\n<li>原始資料有小變動，則希望雜湊值更大的變化</li>\n</ul>\n",
            "tags": [
                "資料結構"
            ]
        }
    ]
}