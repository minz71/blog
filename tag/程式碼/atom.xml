<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.minz.li</id>
    <title>minz的筆記本 • Posts by &#34;程式碼&#34; tag</title>
    <link href="https://blog.minz.li" />
    <updated>2023-11-01T16:00:00.000Z</updated>
    <category term="ShokaX主題" />
    <category term="物件導向" />
    <category term="程式碼" />
    <category term="大學課程" />
    <category term="機率與統計" />
    <category term="演算法" />
    <category term="線性代數" />
    <category term="資料結構" />
    <category term="離散數學" />
    <entry>
        <id>https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9/</id>
        <title>二元搜尋樹</title>
        <link rel="alternate" href="https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9/"/>
        <content type="html">&lt;h1 id=&#34;binary-search-tree&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#binary-search-tree&#34;&gt;#&lt;/a&gt; Binary Search Tree&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

// 定義二元搜尋樹的節點結構
struct Node &amp;#123;
    int data;
    Node* left;
    Node* right;

    // 節點的建構函式
    Node(int value) &amp;#123;
        data = value;
        left = nullptr;
        right = nullptr;
    &amp;#125;
&amp;#125;;

// 搜尋操作
bool search(Node* root, int value) &amp;#123;
    // 若樹為空或找到了目標值，則返回 true
    if (root == nullptr || root-&amp;gt;data == value) &amp;#123;
        return true;
    &amp;#125;

    // 若目標值比根節點的值小，則在左子樹中搜尋
    if (value &amp;lt; root-&amp;gt;data) &amp;#123;
        return search(root-&amp;gt;left, value);
    &amp;#125;

    // 若目標值比根節點的值大，則在右子樹中搜尋
    return search(root-&amp;gt;right, value);
&amp;#125;

// 插入操作
Node* insert(Node* root, int value) &amp;#123;
    // 若樹為空，則創建一個新節點並返回
    if (root == nullptr) &amp;#123;
        return new Node(value);
    &amp;#125;

    // 若目標值比根節點的值小，則插入左子樹中
    if (value &amp;lt; root-&amp;gt;data) &amp;#123;
        root-&amp;gt;left = insert(root-&amp;gt;left, value);
    &amp;#125;

    // 若目標值比根節點的值大，則插入右子樹中
    if (value &amp;gt; root-&amp;gt;data) &amp;#123;
        root-&amp;gt;right = insert(root-&amp;gt;right, value);
    &amp;#125;

    // 返回根節點
    return root;
&amp;#125;

// 刪除操作
Node* remove(Node* root, int value) &amp;#123;
    // 若樹為空，則返回空指針
    if (root == nullptr) &amp;#123;
        return root;
    &amp;#125;

    // 若目標值比根節點的值小，則在左子樹中刪除
    if (value &amp;lt; root-&amp;gt;data) &amp;#123;
        root-&amp;gt;left = remove(root-&amp;gt;left, value);
    &amp;#125;
    // 若目標值比根節點的值大，則在右子樹中刪除
    else if (value &amp;gt; root-&amp;gt;data) &amp;#123;
        root-&amp;gt;right = remove(root-&amp;gt;right, value);
    &amp;#125;
    // 若找到了目標值
    else &amp;#123;
        // 情況1：沒有子節點或只有一個子節點
        if (root-&amp;gt;left == nullptr) &amp;#123;
            Node* temp = root-&amp;gt;right;
            delete root;
            return temp;
        &amp;#125;
        else if (root-&amp;gt;right == nullptr) &amp;#123;
            Node* temp = root-&amp;gt;left;
            delete root;
            return temp;
        &amp;#125;

        // 情況2：有兩個子節點
        // 找到右子樹中的最小值節點
        Node* minNode = root-&amp;gt;right;
        while (minNode-&amp;gt;left != nullptr) &amp;#123;
            minNode = minNode-&amp;gt;left;
        &amp;#125;
        // 複製最小值到目標節點
        root-&amp;gt;data = minNode-&amp;gt;data;
        // 在右子樹中刪除最小值節點
        root-&amp;gt;right = remove(root-&amp;gt;right, minNode-&amp;gt;data);
    &amp;#125;

    // 返回修改後的根節點
    return root;
&amp;#125;

// 測試程式碼
int main() &amp;#123;
    // 建立一個二元搜尋樹
    Node* root = nullptr;
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root= insert(root, 80);

    // 搜尋值 40
    if (search(root, 40)) &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;搜尋到值 40&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;未找到值 40&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    // 刪除值 30
    root = remove(root, 30);

    // 搜尋值 30
    if (search(root, 30)) &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;搜尋到值 30&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;未找到值 30&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們使用  &lt;code&gt;struct&lt;/code&gt;  定義了二元搜尋樹的節點結構，每個節點包含一個整數數據、左子樹指針和右子樹指針。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search&lt;/code&gt;  函式實現了搜尋操作。它遞迴地在二元搜尋樹中搜尋目標值，若樹為空或找到了目標值則返回  &lt;code&gt;true&lt;/code&gt; ，否則根據目標值與根節點數據的比較結果遞迴地在左子樹或右子樹中搜尋。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;insert&lt;/code&gt;  函式實現了插入操作。它遞迴地在二元搜尋樹中找到合適的位置插入新節點，若樹為空則創建一個新節點，否則根據目標值與根節點數據的比較結果遞迴地在左子樹或右子樹中插入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remove&lt;/code&gt;  函式實現了刪除操作。它遞迴地在二元搜尋樹中找到目標值所在的節點，並根據不同情況進行刪除。若目標節點沒有子節點或只有一個子節點，則直接刪除該節點並返回相應的子節點。若目標節點有兩個子節點，則找到右子樹中的最小值節點，將最小值複製到目標節點，然後在右子樹中刪除最小值節點。&lt;/p&gt;
&lt;p&gt;在  &lt;code&gt;main&lt;/code&gt;  函式中，我們插入了一些節點，然後使用  &lt;code&gt;search&lt;/code&gt;  函式搜尋值 40，並根據結果輸出相應的訊息。&lt;br /&gt;
接著，我們刪除值 30 的節點，再次使用  &lt;code&gt;search&lt;/code&gt;  函式搜尋值 30，並根據結果輸出相應的訊息。&lt;/p&gt;
</content>
        <category term="程式碼" />
        <updated>2023-11-01T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/</id>
        <title>排序演算法</title>
        <link rel="alternate" href="https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95/"/>
        <content type="html">&lt;ul&gt;
&lt;li&gt;stable sorting : 相同的值排序後順序皆一樣&lt;/li&gt;
&lt;li&gt;unstable sorting : 相同的值排序後順序可能會不一樣&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;初階排序&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#初階排序&#34;&gt;#&lt;/a&gt; 初階排序&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

// Bubble Sort mark:3-4
void bubbleSort(vector&amp;lt;int&amp;gt;&amp;amp; arr) &amp;#123;
    int n = arr.size();
    for (int i = 0; i &amp;lt; n - 1; i++) &amp;#123;
        for (int j = 0; j &amp;lt; n - i - 1; j++) &amp;#123;
            if (arr[j] &amp;gt; arr[j + 1]) &amp;#123;
                swap(arr[j], arr[j + 1]);
            &amp;#125;
        &amp;#125;
    &amp;#125;
&amp;#125;

// Selection Sort
// 1. 先選這輪的最小
// 2. 跟i交換
void selectionSort(vector&amp;lt;int&amp;gt;&amp;amp; arr) &amp;#123;
    int n = arr.size();
    for (int i = 0; i &amp;lt; n - 1; i++) &amp;#123;
        int minIndex = i;
        for (int j = i + 1; j &amp;lt; n; j++) &amp;#123;
            if (arr[j] &amp;lt; arr[minIndex]) &amp;#123;
                minIndex = j; 
            &amp;#125;
        &amp;#125;
        swap(arr[i], arr[minIndex]);
    &amp;#125;
&amp;#125;

// Insertion Sort
// 1. 依序給這一輪的value
// 2. value跟前面的比
// 3. 放到完成的位置
void insertionSort(vector&amp;lt;int&amp;gt;&amp;amp; arr) &amp;#123;
    int n = arr.size();
    for (int i = 1; i &amp;lt; n; i++) &amp;#123;
        int key = arr[i];
        int j = i - 1;
        while (j &amp;gt;= 0 &amp;amp;&amp;amp; arr[j] &amp;gt; key) &amp;#123;
            arr[j + 1] = arr[j];
            j--;
        &amp;#125;
        arr[j + 1] = key;
    &amp;#125;
&amp;#125;

int main() &amp;#123;
    vector&amp;lt;int&amp;gt; arr = &amp;#123;5, 2, 8, 3, 1&amp;#125;;

    // Bubble Sort
    bubbleSort(arr);
    cout &amp;lt;&amp;lt; &amp;quot;Bubble Sort: &amp;quot;;
    for (int num : arr) &amp;#123;
        cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    // Selection Sort
    arr = &amp;#123;5, 2, 8, 3, 1&amp;#125;;
    selectionSort(arr);
    cout &amp;lt;&amp;lt; &amp;quot;Selection Sort: &amp;quot;;
    for (int num : arr) &amp;#123;
        cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    // Insertion Sort
    arr = &amp;#123;5, 2, 8, 3, 1&amp;#125;;
    insertionSort(arr);
    cout &amp;lt;&amp;lt; &amp;quot;Insertion Sort: &amp;quot;;
    for (int num : arr) &amp;#123;
        cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;quick-sort&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#quick-sort&#34;&gt;#&lt;/a&gt; Quick sort&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

// 快速排序 (Quick Sort)
// 最壞情況時間複雜度：O(n^2)
// 平均情況時間複雜度：O(nlogn)
// 最佳情況時間複雜度：O(nlogn)
int partition(vector&amp;lt;int&amp;gt;&amp;amp; arr, int low, int high) &amp;#123;
    int pivot = arr[high]; // 選擇最後一個元素作為主元
    int i = low - 1;

    for (int j = low; j &amp;lt; high; j++) &amp;#123;
        if (arr[j] &amp;lt; pivot) &amp;#123;
            i++;
            swap(arr[i], arr[j]);
        &amp;#125;
    &amp;#125;

    swap(arr[i + 1], arr[high]);
    return i + 1;
&amp;#125;

void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; arr, int low, int high) &amp;#123;
    if (low &amp;lt; high) &amp;#123;
        int pivotIndex = partition(arr, low, high);

        // 遞迴地對分割後的子陣列進行排序
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    &amp;#125;
&amp;#125;
int main() &amp;#123;
    vector&amp;lt;int&amp;gt; arr = &amp;#123;5, 2, 8, 3, 1&amp;#125;;

    // 快速排序
    cout &amp;lt;&amp;lt; &amp;quot;快速排序結果：&amp;quot; &amp;lt;&amp;lt; endl;
    quickSort(arr, 0, arr.size() - 1);
    for (int num : arr) &amp;#123;
        cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在快速排序中，我們使用  &lt;code&gt;partition&lt;/code&gt;  函式將陣列分割為比主元小和比主元大的兩個子陣列。&lt;br /&gt;
然後，我們遞迴地對這兩個子陣列進行排序，直到排序完成。&lt;/p&gt;
</content>
        <category term="程式碼" />
        <updated>2023-11-01T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%9F%A9%E9%99%A3%E9%A1%8C%E7%9B%AE/</id>
        <title>矩陣程式題目</title>
        <link rel="alternate" href="https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E7%9F%A9%E9%99%A3%E9%A1%8C%E7%9B%AE/"/>
        <content type="html">&lt;h1 id=&#34;找出矩陣中第二大的數字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#找出矩陣中第二大的數字&#34;&gt;#&lt;/a&gt; 找出矩陣中第二大的數字&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;climits&amp;gt; // 包含 INT_MIN 的定義

using namespace std;

int findSecondLargest(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) &amp;#123;
    int largest = INT_MIN; // 最大數字
    int secondLargest = INT_MIN; // 第二大數字

    // 遍歷矩陣，找出最大數字和第二大數字
    for (const auto&amp;amp; row : matrix) &amp;#123;
        for (int num : row) &amp;#123;
            if (num &amp;gt; largest) &amp;#123;
                secondLargest = largest;
                largest = num;
            &amp;#125; else if (num &amp;gt; secondLargest &amp;amp;&amp;amp; num &amp;lt; largest) &amp;#123;
                secondLargest = num;
            &amp;#125;
        &amp;#125;
    &amp;#125;

    return secondLargest;
&amp;#125;

int main() &amp;#123;
    // 定義矩陣
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; matrix = &amp;#123;
        &amp;#123;4, 5, 6&amp;#125;,
        &amp;#123;7, 10, 9&amp;#125;,
        &amp;#123;2, 8, 3&amp;#125;
    &amp;#125;;

    // 呼叫函式找出第二大的數字
    int secondLargest = findSecondLargest(matrix);

    // 輸出結果
    if (secondLargest != INT_MIN) &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;矩陣中第二大的數字為: &amp;quot; &amp;lt;&amp;lt; secondLargest &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;矩陣中沒有第二大的數字&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;轉置矩陣&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#轉置矩陣&#34;&gt;#&lt;/a&gt; 轉置矩陣&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

const int MAX_SIZE = 100;  // 定義矩陣的最大大小

// 函數：計算矩陣的轉置
void transposeMatrix(int matrix[][MAX_SIZE], int rows, int cols) &amp;#123;
    int transposedMatrix[MAX_SIZE][MAX_SIZE];  // 用於儲存轉置後的矩陣

    // 遍歷矩陣元素，進行轉置
    for (int i = 0; i &amp;lt; rows; i++) &amp;#123;
        for (int j = 0; j &amp;lt; cols; j++) &amp;#123;
            transposedMatrix[j][i] = matrix[i][j];
        &amp;#125;
    &amp;#125;

    // 列印轉置後的矩陣
    cout &amp;lt;&amp;lt; &amp;quot;轉置矩陣：&amp;quot; &amp;lt;&amp;lt; endl;
    for (int i = 0; i &amp;lt; cols; i++) &amp;#123;
        for (int j = 0; j &amp;lt; rows; j++) &amp;#123;
            cout &amp;lt;&amp;lt; transposedMatrix[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        &amp;#125;
        cout &amp;lt;&amp;lt; endl;
    &amp;#125;
&amp;#125;

int main() &amp;#123;
    int matrix[MAX_SIZE][MAX_SIZE];  // 定義原始矩陣
    int rows, cols;  // 矩陣的行數和列數

    // 輸入矩陣的行數和列數
    cout &amp;lt;&amp;lt; &amp;quot;請輸入矩陣的行數：&amp;quot;;
    cin &amp;gt;&amp;gt; rows;
    cout &amp;lt;&amp;lt; &amp;quot;請輸入矩陣的列數：&amp;quot;;
    cin &amp;gt;&amp;gt; cols;

    // 輸入矩陣元素
    cout &amp;lt;&amp;lt; &amp;quot;請輸入矩陣的元素：&amp;quot; &amp;lt;&amp;lt; endl;
    for (int i = 0; i &amp;lt; rows; i++) &amp;#123;
        for (int j = 0; j &amp;lt; cols; j++) &amp;#123;
            cin &amp;gt;&amp;gt; matrix[i][j];
        &amp;#125;
    &amp;#125;

    // 調用函數計算矩陣的轉置
    transposeMatrix(matrix, rows, cols);

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;兩個矩陣相乘&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#兩個矩陣相乘&#34;&gt;#&lt;/a&gt; 兩個矩陣相乘&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

// 函式：矩陣相乘
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; matrixMultiply(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix1, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix2) &amp;#123;
    int rows1 = matrix1.size();    // 矩陣1的列數
    int cols1 = matrix1[0].size(); // 矩陣1的行數（矩陣2的列數）
    int cols2 = matrix2[0].size(); // 矩陣2的行數

    // 建立結果矩陣，初始化為全0
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result(rows1, vector&amp;lt;int&amp;gt;(cols2, 0));

    // 進行矩陣相乘運算
    for (int i = 0; i &amp;lt; rows1; i++) &amp;#123;
        for (int j = 0; j &amp;lt; cols2; j++) &amp;#123;
            for (int k = 0; k &amp;lt; cols1; k++) &amp;#123;
                result[i][j] += matrix1[i][k] * matrix2[k][j];
            &amp;#125;
        &amp;#125;
    &amp;#125;

    return result;
&amp;#125;

int main() &amp;#123;
    // 定義兩個矩陣
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; matrix1 = &amp;#123;&amp;#123;1, 2&amp;#125;, &amp;#123;3, 4&amp;#125;&amp;#125;;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; matrix2 = &amp;#123;&amp;#123;5, 6&amp;#125;, &amp;#123;7, 8&amp;#125;&amp;#125;;

    // 呼叫矩陣相乘函式
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result = matrixMultiply(matrix1, matrix2);

    // 輸出結果矩陣
    cout &amp;lt;&amp;lt; &amp;quot;矩陣相乘的結果：&amp;quot; &amp;lt;&amp;lt; endl;
    for (const auto&amp;amp; row : result) &amp;#123;
        for (const auto&amp;amp; element : row) &amp;#123;
            cout &amp;lt;&amp;lt; element &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        &amp;#125;
        cout &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;矩陣乘向量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#矩陣乘向量&#34;&gt;#&lt;/a&gt; 矩陣乘向量&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

// 計算矩陣與向量的乘積
vector&amp;lt;double&amp;gt; matrixVectorMultiply(const vector&amp;lt;vector&amp;lt;double&amp;gt;&amp;gt;&amp;amp; matrix, const vector&amp;lt;double&amp;gt;&amp;amp; vector) &amp;#123;
    int rows = matrix.size();
    int cols = matrix[0].size();

    // 檢查矩陣與向量的尺寸是否符合乘法規則
    if (cols != vector.size()) &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;矩陣與向量的尺寸不符合乘法規則&amp;quot; &amp;lt;&amp;lt; endl;
        return vector&amp;lt;double&amp;gt;();
    &amp;#125;

    // 創建結果向量，初始化為零
    vector&amp;lt;double&amp;gt; result(rows, 0.0);

    // 進行矩陣與向量的乘法
    for (int i = 0; i &amp;lt; rows; i++) &amp;#123;
        for (int j = 0; j &amp;lt; cols; j++) &amp;#123;
            result[i] += matrix[i][j] * vector[j];
        &amp;#125;
    &amp;#125;

    return result;
&amp;#125;

// 測試程式碼
int main() &amp;#123;
    // 定義矩陣
    vector&amp;lt;vector&amp;lt;double&amp;gt;&amp;gt; matrix = &amp;#123;&amp;#123;1, 2, 3&amp;#125;,
                                     &amp;#123;4, 5, 6&amp;#125;,
                                     &amp;#123;7, 8, 9&amp;#125;&amp;#125;;

    // 定義向量
    vector&amp;lt;double&amp;gt; vector = &amp;#123;1, 2, 3&amp;#125;;

    // 計算矩陣與向量的乘積
    vector&amp;lt;double&amp;gt; result = matrixVectorMultiply(matrix, vector);

    // 輸出結果
    cout &amp;lt;&amp;lt; &amp;quot;乘積結果：&amp;quot;;
    for (double value : result) &amp;#123;
        cout &amp;lt;&amp;lt; value &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="程式碼" />
        <updated>2023-11-01T16:00:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%A1%8C%E7%9B%AE/</id>
        <title>程式題目</title>
        <link rel="alternate" href="https://blog.minz.li/%E9%9D%A2%E8%A9%A6%E9%A1%8C%E7%9B%AE/%E9%A1%8C%E7%9B%AE/"/>
        <content type="html">&lt;h1 id=&#34;印星星&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#印星星&#34;&gt;#&lt;/a&gt; 印星星&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

void printUpperTriangle(int n) &amp;#123;
    for (int i = 0; i &amp;lt; n; i++) &amp;#123;
        for (int j = 0; j &amp;lt;= i; j++) &amp;#123;
            cout &amp;lt;&amp;lt; &amp;quot;* &amp;quot;;
        &amp;#125;
        cout &amp;lt;&amp;lt; endl;
    &amp;#125;
&amp;#125;

void printLowerTriangle(int n) &amp;#123;
    for (int i = n; i &amp;gt; 0; i--) &amp;#123;
        for (int j = 0; j &amp;lt; i; j++) &amp;#123;
            cout &amp;lt;&amp;lt; &amp;quot;* &amp;quot;;
        &amp;#125;
        cout &amp;lt;&amp;lt; endl;
    &amp;#125;
&amp;#125;

int main() &amp;#123;
    int n;
    cout &amp;lt;&amp;lt; &amp;quot;請輸入行數: &amp;quot;;
    cin &amp;gt;&amp;gt; n;

    cout &amp;lt;&amp;lt; &amp;quot;上三角形：&amp;quot; &amp;lt;&amp;lt; endl;
    printUpperTriangle(n);

    cout &amp;lt;&amp;lt; &amp;quot;下三角形：&amp;quot; &amp;lt;&amp;lt; endl;
    printLowerTriangle(n);

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;用遞迴寫階乘&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#用遞迴寫階乘&#34;&gt;#&lt;/a&gt; 用遞迴寫階乘&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

// 定義遞迴函式計算階乘
int factorial(int n) &amp;#123;
    // Base case: 當 n 為 0 或 1 時，階乘為 1
    if (n == 0 || n == 1) &amp;#123;
        return 1;
    &amp;#125;
    // 遞迴呼叫：將問題分解為較小的子問題
    // 階乘 n 可以表示為 n 乘上 (n-1) 的階乘
    return n * factorial(n - 1);
&amp;#125;

int main() &amp;#123;
    int num;
    cout &amp;lt;&amp;lt; &amp;quot;請輸入一個正整數: &amp;quot;;
    cin &amp;gt;&amp;gt; num;

    // 呼叫遞迴函式計算階乘
    int result = factorial(num);

    cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; 的階乘是: &amp;quot; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;找出陣列中第二大的數字&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#找出陣列中第二大的數字&#34;&gt;#&lt;/a&gt; 找出陣列中第二大的數字&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int findSecondLargest(int arr[], int size) &amp;#123;
    int largest = INT_MIN;  // 初始化最大值為int類型的最小值
    int secondLargest = INT_MIN;  // 初始化第二大值為int類型的最小值

    // 遍歷數組，更新最大值和第二大值
    for (int i = 0; i &amp;lt; size; i++) &amp;#123;
        if (arr[i] &amp;gt; largest) &amp;#123;
            secondLargest = largest;
            largest = arr[i];
        &amp;#125; else if (arr[i] &amp;gt; secondLargest &amp;amp;&amp;amp; arr[i] != largest) &amp;#123;
            secondLargest = arr[i];
        &amp;#125;
    &amp;#125;

    return secondLargest;
&amp;#125;

int main() &amp;#123;
    int arr[] = &amp;#123;5, 2, 9, 1, 7, 4&amp;#125;;  // 範例數組
    int size = sizeof(arr) / sizeof(arr[0]);  // 計算數組大小

    // 調用函數找到第二大的數
    int secondLargest = findSecondLargest(arr, size);

    cout &amp;lt;&amp;lt; &amp;quot;第二大的數字是: &amp;quot; &amp;lt;&amp;lt; secondLargest &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;給定一數字找出因數&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#給定一數字找出因數&#34;&gt;#&lt;/a&gt; 給定一數字，找出因數&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

// 找出給定數字的因數
vector&amp;lt;int&amp;gt; findFactors(int num) &amp;#123;
    vector&amp;lt;int&amp;gt; factors;

    // 從 1 開始遍歷到 num 的平方根
    for (int i = 1; i * i &amp;lt;= num; i++) &amp;#123;
        if (num % i == 0) &amp;#123;
            factors.push_back(i); // 將因數 i 加入 factors
            if (i != num / i) &amp;#123;
                factors.push_back(num / i); // 將因數 num/i 加入 factors
            &amp;#125;
        &amp;#125;
    &amp;#125;

    return factors;
&amp;#125;

int main() &amp;#123;
    int num;
    cout &amp;lt;&amp;lt; &amp;quot;請輸入一個正整數：&amp;quot;;
    cin &amp;gt;&amp;gt; num;

    vector&amp;lt;int&amp;gt; factors = findFactors(num);

    cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot; 的因數有：&amp;quot;;
    for (int factor : factors) &amp;#123;
        cout &amp;lt;&amp;lt; factor &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    &amp;#125;
    cout &amp;lt;&amp;lt; endl;

    return 0;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;判斷質數&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判斷質數&#34;&gt;#&lt;/a&gt; 判斷質數&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;

using namespace std;

// 判斷一個數字是否為質數
bool isPrime(int number) &amp;#123;
    // 負數和小於等於 1 的數字不是質數
    if (number &amp;lt;= 1) &amp;#123;
        return false;
    &amp;#125;

    // 使用平方根的方法進行質數判斷
    // 如果一個數字 n 是合數（非質數）
    // 那麼它必定可以分解為兩個因數 a 和 b
    // 其中 a 和 b 都不大於 sqrt(n)
    int sqrtNumber = sqrt(number);
    for (int i = 2; i &amp;lt;= sqrtNumber; i++) &amp;#123;
        if (number % i == 0) &amp;#123;
            return false;
        &amp;#125;
    &amp;#125;

    // 如果沒有找到能整除 number 的數字，則 number 是質數
    return true;
&amp;#125;

// 測試程式碼
int main() &amp;#123;
    int number;

    cout &amp;lt;&amp;lt; &amp;quot;請輸入一個數字：&amp;quot;;
    cin &amp;gt;&amp;gt; number;

    // 呼叫 isPrime 函式判斷是否為質數
    bool result = isPrime(number);

    // 根據結果輸出訊息
    if (result) &amp;#123;
        cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; 是質數&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; number &amp;lt;&amp;lt; &amp;quot; 不是質數&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;判斷子字串&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判斷子字串&#34;&gt;#&lt;/a&gt; 判斷子字串&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

using namespace std;

// 判斷一個字串是否為另一個字串的子字串
bool isSubstring(const string&amp;amp; str, const string&amp;amp; substring) &amp;#123;
    // 如果子字串長度大於原始字串，則直接返回 false
    if (substring.length() &amp;gt; str.length()) &amp;#123;
        return false;
    &amp;#125;

    // 遍歷原始字串，逐個比較字元
    for (size_t i = 0; i &amp;lt;= str.length() - substring.length(); i++) &amp;#123;
        bool isMatch = true;

        // 檢查子字串是否匹配
        for (size_t j = 0; j &amp;lt; substring.length(); j++) &amp;#123;
            if (str[i + j] != substring[j]) &amp;#123;
                isMatch = false;
                break;
            &amp;#125;
        &amp;#125;

        // 如果子字串匹配，則返回 true
        if (isMatch) &amp;#123;
            return true;
        &amp;#125;
    &amp;#125;

    // 沒有找到匹配的子字串，返回 false
    return false;
&amp;#125;

// 測試程式碼
int main() &amp;#123;
    string str, substring;

    cout &amp;lt;&amp;lt; &amp;quot;請輸入一個字串：&amp;quot;;
    getline(cin, str);

    cout &amp;lt;&amp;lt; &amp;quot;請輸入一個子字串：&amp;quot;;
    getline(cin, substring);

    // 呼叫 isSubstring 函式判斷是否為子字串
    bool result = isSubstring(str, substring);

    // 根據結果輸出訊息
    if (result) &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;\\&amp;quot;&amp;quot; &amp;lt;&amp;lt; substring &amp;lt;&amp;lt; &amp;quot;\\&amp;quot; 是 \\&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot;\\&amp;quot; 的子字串&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;\\&amp;quot;&amp;quot; &amp;lt;&amp;lt; substring &amp;lt;&amp;lt; &amp;quot;\\&amp;quot; 不是 \\&amp;quot;&amp;quot; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &amp;quot;\\&amp;quot; 的子字串&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用迴圈逐個比較字元的方式來實現。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;檢查子字串的長度是否大於原始字串的長度，如果是，則直接返回 false，因為子字串不可能是原始字串的子字串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用兩個嵌套的迴圈。外層迴圈遍歷原始字串，內層迴圈檢查從當前位置開始的子字串是否匹配。如果在內層迴圈中找到了不匹配的字元，則設置  &lt;code&gt;isMatch&lt;/code&gt;  為 false，並且跳出內層迴圈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="程式碼" />
        <updated>2023-11-01T16:00:00.000Z</updated>
    </entry>
</feed>
